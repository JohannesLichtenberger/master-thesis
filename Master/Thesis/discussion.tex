\section{Discussion}\label{sec::discussion}
\subsection{Introduction}
This Chapter concludes with a discussion of the work presented in relation to the state-of-the-art.

The presented approach facilitates the comparison of tree-structures through various linked visualizations depicting the tree-structures at various levels of detail. Small multiple displays provide a high level view of the differences between multiple tree-structures. Linking and brushing is used to highlight nodes. The \emph{SunburstView} incorporates both a mode to visualize one tree-structure and a mode to visualize comparisons between two tree-structures. A new layout-algorithm facilitates comparing tree-structures through highlighting changes in a prominent place with a global distortion. Furthermore different filtering methods allow the comparison of large trees. Details are shown on demand through a mouseover effect and a linked \texttt{TextView}. A selection of a new root-node togehter with a simple undo-operation allows to drill down into the tree as known from other Sunburst-visualizations. However costly recalculation of diff-tuples, modifications and subtree-sizes of each node is omitted in all cases but the itemsize-based pruning. Instead we recalculate the maximum depth of unchanged nodes and scale a new list of items to fit the new boundaries. The \texttt{TextView} provides a serialization of (sub)trees linked with the \texttt{SunburstView} also tailored to large tree-structures.

Unlike state-of-the-art visualizations of tree comparisons described in Chapter \ref{sec::relwork} our approach is entirely database driven. The DBMS is tailored to temporal tree-structures which are stored as snapshots. Each node in the database/resource is unique and remains stable throughout all revisions. As most trees do not inhibit unique node-IDs we implemented an ID-less diff-algorithm called FMSE based on inner-node/leaf-node similarity measures to import differences, which eventuates in a new revision. Afterwards we are able to use a fast diff-algorithm ($O(n+m)$) based on the generated node-IDs and furthermore are able to utilize hashes to further speed up the algorithm. Due to FMSE our similarity-measure between trees is based on a matching algorithm which computes the longest common subsequence (LCS) bottom up and furthermore tries to find cross-matches of unmatched nodes.

The next section evaluates our approach similar to Chapter \ref{sec::relwork} according to several attributes.

\subsection{Evaluation Criteria}

\begin{itemize}
\item \emph{SpaceFilling} Space filling techniques try to maximize the usage of available screen space and thus facilitate a higher information density. Sunburst layouts are generally space filling, but in contrast to Treemaps lack space filling properties in the corners. However in our case the corners are used to display GUI components and legends. The small multiple variants currently have too much unused space which is due to the often times non squarified screen viewport depending on the extends of the main window. As we just scale each visualization of the comparison of each two revisions the small multiple variants currently include too much unused space due to often times non squarified screen viewport which depends (1) on the size of the main window and (2) how many visualizations are currently enabled. Thus, in a future version we will use a squarified clip of the view depending on the maximum depth to generate minimized offscreen buffers for the four regions. Other space filling approaches include Icicle plots (Code Flows) which are comparable in space consumption as always the two complete tree-structures to compare are plottet. In our case unchanged nodes are not plotted twice. Furthermore a special stable Spiral-Treemap layout has been proposed which utilizes all available screen space and remains relatively stable after changes. Usual Treemap layouts suffer from abrupt layout changes during modifications of the underlying data.
\item \emph{Hierarchy} The Hierarchy in Sunburst layouts is very well depicted due to the adjacency based layout whereas it is not as obvious in Treemaps which encapsulate child items. Cushion Treemaps have been developed for better readability of hierarchical relationships using shading. However they are still not as good readable as in adjacency based layouts. Code flows utilizes Icicle plots which are rectangular views of the radial Sunburst layout, thus adjacency based and very well readable. Our approach optionally plots a node-link diagram on top of the Sunburst layout to further illustrate the relationships such that the hierarchy is at least as well depicted as in other node-link diagrams (for instance in TreeJuxtaposer and Treevolution). 
\item \emph{Readability} To both use node-link diagrams and a Sunburst layout facilitates a higher information density as individual nodes can be color-coded as well as their child/parent relationship, the links between the nodes. Thus we are able to map certain attributes to the arc/extension of the Sunburst items, the color of the arcs and the color of the dots/nodes in the node-link diagram. To maximize the information density we could also use histograms in the Sunburst items instead of just using one color for the whole item. However we assume that usually the items will be too small, such that a whole histogram would certainly not be readable. To support better readability of item-labels our visualization is able to be rotated. However, node labels of Treemaps and Icicle plots usually are better readable due to their rectangular display in comparison to circular plotted labels. Thus we decided to extend our \emph{TextView} to take the agglomerated tree-structure into account. It is an ideal partner of the \emph{SunburstView} as it provides better readability of small subtrees but lacks the overview about the entire tree-structure and all differences provided by the \emph{SunburstView}. 
\item \emph{Similarity of ID-less tree-structures} Some proposed tree-to-tree comparsion visualizations depend on node-IDs (Spiral-/Contrast-Treemap\cite{tu2007visualizing}) or the comparison technique has not been meantioned. Others depend on domain characteristics (Treejuxtaposer\cite{munzner2003treejuxtaposer}, Code Flows\cite{telea2008code}). Juxtaposer seems to rely on unique leaf node labels. Otherwise it is not obvious how to map node labels to their postorder rank on a region plane. In contrast to Treejuxtaposer and other proposed systems our prototype is able to compare every kind of tree-structure.
\item \emph{Structural changes} Our visualizations, in particular the \emph{SunburstView} and the small multiple display variants support the highlighting of all kind of structural-changes (inserts, deletes, updates, replace and move-operations) through color-coded nodes. In case of moves- links, currently depicted as arrows, denote the movement from their original- to their target-place using hierarchical edge bundling to avoid or at least reduce visual clutter due to overlapping lines or curves. Furthermore the extend of the sunburst items is based on the nodes' subtree size \emph{and} the number of modifications in the subtree. Most other visualizations do provide a global distortion to further emphasize changes except Treejuxtaposer to the best of our knowledge.
\item \emph{Non structural changes} are attribute-value changes of nodes. Changes in \texttt{TextNode}s are color coded to denote that the value is \texttt{UPDATED} through coloring the node in the overlapping node-link diagram accordingly. Furthermore the color of the Sunburst item reflects their similarity using the Levenshtein distance.
\item \emph{Filtering} is one of our primariy concerns. The focus of this thesis evolved around comparing Treetank-resources. As Treetank is a secure storage system it naturally often times stores very large tree-structures. Thus our first consideration was to prune items which cannot be perceived, that is too small items are not created. However this only effects the creation of SunburstItems and does not concern the ID-based diff-algorithm. To speed up both, the ID-based diff algorithm as well as the construction of SunburstItems we developed the diff-algorithm which skips subtrees with same hashes and moves both transactions to the next node on the XPath-following axis. Thus, in case large subtrees can be skipped the diff-algorithm using hash-comparisons is much faster. Besides even less items have to be created and in case of a subtree-selection only the itemsizes have to be recalculated instead of reinvoking the diff-algorithm, recalculate the descendant- and modification-count, and the whole preorder traversal of the agglomerated tree-structure with all stack-adjustements. Pushing the idea of filtering by hashvalues to its limits involves to avoid the creation of SunburstItems for the nodes, which have the same hashvalues. These filtering techniques furthermore enlarge changed subtrees naturally as the arc of the items is based on the \emph{subtree-size} of each node and the number of \emph{modifications} therein. TreeJuxtaposer once more along with Code Flows to the best of our knowledge seem to be the only systems which are able to handle large tree-structures but the diff-algorithm of TreeJuxtaposer relies on unique node labels. Code Flows does not provide a global filtering method such that their filtering is comparable with our method to drill down into the tree. However, due to filtering by queries the filtering is mightier. Implementing such a behavior in our prototype will be straight forward allowing the user to specify an XPath-query and invoke the diff-algorithm for each result on both revisions. Our current approach is able to filter differences and related context nodes on a global basis and on subtrees once a user drilled down into the Sunburst visualization with a guaranteed visibility of modifications much like in TreeJuxtaposer.
\end{itemize}

\subsection{Summary}
Table \ref{chap5:comparsion} summarizes the visualizations according to the evaluation criterias specified.

\begin{table}[tb]
\centering 
\begin{tabular}[r]{|l|c|c|c|c|c|c|} 
\hline
& \begin{sideways}\textbf{space filling}\end{sideways} & \begin{sideways}\textbf{hierarchy}\end{sideways} & \begin{sideways}\textbf{readability}\end{sideways} & \begin{sideways}\textbf{structural changes}\end{sideways} & \begin{sideways}\textbf{non structural changes}\end{sideways} & \begin{sideways}\textbf{filtering}\end{sideways}\\
\hline
\hline
\textbf{Sunburst} & ++ & +++ & ++ & +++ & ++ & +++\\
\hline
\textbf{Spiral-/Contrast-Treemap} & +++ & + & + & + & +++ & -\\
\hline
\textbf{Treevolution} & - & ++ & + & + & - & -\\
\hline
\textbf{Code Flows} & +++ & +++ & ++ & ++ & - & +\\
\hline
\textbf{Juxtaposer} & - & +++ & + & ++ & - & ++ \\
\hline
\textbf{Ripple Presentation} & - & ++ & + & + & - & -\\
\hline
\textbf{IVCoMT} & +\footnote{the matrix view} & +++ & +++ & ++ & - & - \\
\hline
\end{tabular}
\label{chap5:comparsion}
\vspace{0.5em} 
\caption{Comparsion of tree-to-tree comparison visualizations. "-" indicates the absence of an attribute, "+" to "+++" implies how well or bad the attribute is supported.}
\end{table}

Most proposed visualizations rely on stable unique IDs (the Contrast Treemap\cite{tu2007visualizing}, Code Flows\cite{telea2008code}, TreeJuxtaposer\cite{munzner2003treejuxtaposer} (unique node labels)) and do not include the detection of \texttt{replace}- and \texttt{move}-operations. However Code Flows visualizes moves due to spline connections between matching nodes with the same ID in two adjacent icicle plots. Due to the reliability on unique node IDs these visualizations do not cover trees which do not include unique node-IDs or labels. In contrast our prototype is able to determine and visualize these tree-structures utilizing the FMSE-algorithm to import differences through similarity metrics for leaf- and inner-nodes and a bottom-up LCS computation.

Interactive Visual Comparison of Multiple Trees(IVCoMT\cite{bremm2011interactive}) provides the ability to compare multiple trees through various linked views allowing the comparison on different levels. However we assume that the similarity metrics are defined for phylogenetic trees which have unique labels and that the visualizations are tailored to many small trees in comparison to a few very large tree-structures or a temporal evolving tree as in our case.
