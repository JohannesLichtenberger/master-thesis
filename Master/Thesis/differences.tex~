\section{Analysis of structural differences}\label{sec::differences}
\subsection{Introduction}
This chapter describes the implementation of an ID-less algorithm (FMSE, described in the last chapter (\ref{subsec::ladiff})) as well as a new ID-based algorithm which utilizes a preorder traversals on both trees to compare tuples of two nodes each time. The FMSE algorithm facilitates the import of differences between two tree-structures which do not incorporate unique node-IDs in the first place either to compare different, similar tree-structures or the evolution of a tree. Thus, our similarity measures are based on the tree-to-tree correction problem. The visualizations proposed in the next chapter rely on diff-algorithms which detect edit-operations/diff-types to transform a source tree into a target tree. A reference tree is initially imported in Treetank. Subsequently the changes between this tree and other trees or the evolution of the reference-tree in terms of edit-operations are stored as subsequent revisions. As described in the last chapter, the Fast Matching Simple Editscript algorithm depends on similarity-measures and does not require nor use unique node-IDs in our case. Thus, a minimum edit-sequence usually is not guaranteed. While importing the differences through FMSE, Treetank assignes unique stable node-IDs which are subsequently utilized to support a fast linear-runtime difference-computation. Fig. \ref{fig:importdata} describes the import using FMSE and a subsequent ID-based diff-algorithm. The encountered diff-tuples which include the diff-type, the compared nodes and their depth in the tree by comparing two nodes of both revisions each time in turn facilitate an aggregated tree-structure made up of both changed- and unchanged-nodes through collecting the diff-tuples in the model of a visualization as described in the next chapter (Chapter \ref{sec::visualizations}). 

\begin{figure}[tb]
\centering
\includegraphics[width=\textwidth]{figures/importdata}
\caption{Importing differences encountered through the FMSE ID-based diffing-algorithm.} 
\label{fig:importdata}
\end{figure}

Both algorithms, the ID-less FMSE algorithm used for importing differences and the subsequent fast ID-based diff-algorithm are implemented using Treetanks' transaction-based Java-API, the native secure tree-storage system, which is used as an integral part to demonstrate our approach. After a short description of Treetank the implementation of several new edit-operations is described to support the FMSE-algorithm and a compact, meaningful aggregated tree-structure. As a general remark, Treetank now supports all operators specified by the XQuery Update Facility (XQUF)\footnote{\texttt{INSERT INTO AS LAST} has to be wrapped as we currently do not provide last child pointers}. In addition \texttt{move}-operations have been added. Note that a rich set of edit-operations facilitates an expressive visualization. It is much more intuitive and meaningful to provide atomar \texttt{replace}- and \texttt{move}-operations to reflect changes between tree-structures than to simply use combinations of \texttt{delete}- and \texttt{insert}-operations without any association. 

\subsection{Storage backend}
Treetank, as meantioned before, is an effective and efficient secure storage system tailored to revisioned tree-structures. Currently it supports the import of XML documents which is commonly referred to as \emph{shredding}. To process stored data the W3C recommendations XPath 2.0, XQuery 1.0 and XSLT 2.0\footnote{parts of the XPath 2.0 recommendation have been implemented, alternatively the Saxon XPath 2.0 binding can be used which also offers the XQuery 1.0 and XSLT 2.0 support}, as well as a cursor like Java-API using transactions is supported. The architecture is based on four exchangeable vertical aligned layers. The following is a brief description of each layer in a top-down approach:

\begin{description}
\item[Transaction] Transactions are divided into \texttt{read}- and \texttt{write}-transactions. Read-Transactions are able to read stored nodes through a cursor-like API. Write-Transactions extend the functionality of Read-Transactions and provide both read- and write-semantics. They aditionally provide methods to modify data and commit the changes to store a new revision. Changes are atomar and saved in a transaction log which literally means they are either commited at a whole or aborted and rolled back. All ACID-properties are supported. Commiting changes results in a new appended revision, whereas nodes internally are stored based on a copy-on-write (COW) principle and a revisioning approach (full, incremental, differential and a new sliding-window based hybrid). Aborting a transaction means that all modifications issued during the transaction after the last commit are not persisted and lost. Update operations are applied immediately in main-memory but saved in a transaction log which is used to persist the changes after a commit. Consistency rules apply either at pre-commit time or at the time a transaction is commited.

Every transaction includes a unique transaction ID as well as a timestamp which denotes the last commit-time of the transaction.

\item[Node] The node layer is responsible for providing different node kinds. Currently \texttt{comment} and \texttt{processing-instruction} nodes are not supported due to the prototype research state of Treetank which is sufficient in almost all cases. Note that adding these two node types in general is straight forward. The node- and transaction-layer are responsible for the storage encoding. The main focus of the node-layer is the update-performance. Thus the pointers are stored eventuating in a local \\\texttt{key/parentKey/firstChildKey/[left|right]SiblingKey} encoding illustrated in Fig. \ref{fig:encoding}. The dashed lastChild pointer currently is not available but may be added to support efficient XPath-queries as for instance the \texttt{fn:last()}-function to get the last-element in a context-set. 

%Inserting a structural node either involves calling \texttt{insertAsFirstChild()} or \texttt{insertAsRightSibling()} on a write transaction. The first case requires to set

%\begin{itemize}
%\item the parent key to the current key located at the current transaction cursor position (before the insert)
%\item a special \texttt{NULL\_NODE\_KEY} to mark the nonexistence of any left sibling
%\item the former first child as the right sibling
%\end{itemize}

%The latter case requires to set

%\begin{itemize}
%\item the parent key to the current parent key
%\item the left sibling key to the current node key
%\item the right sibling key to the current right sibling key
%\end{itemize}

All changes are local with a constant runtime overhead and affect at most neighbour-/parent-/child-nodes. Besides fixed length data, as the pointers to sibling/parent/firstChild nodes (which also is stored in a compressed variable length form), variable content might be stored in the node itself. For instance a hash which is used for ensuring integrity of the nodes' subtree and build through the references between the nodes is stored. In our context these hashes set the stage for an efficient ID-based diff-algorithm by comparing the hash values which is described later on in this chapter. However storing hashes (which also enables the storage of the number of descendants) at least involves updating all ancestor nodes as well depending on the specified hash-algorithm at the time generating a database.

\begin{figure}[tb]
\centering
\includegraphics[width=0.45\textwidth]{figures/encoding}
\caption{Treetank encoding} 
\label{fig:encoding}
\end{figure}

\item[Page] The page-layer is motivated by ZFS \cite{ZFS}. It takes care of persisting nodes and is designed for the efficient storage of versioned tree-structures. The pages are stored in a rooted tree. A so called \emph{UberPage} contains indirect references (through references to \emph{IndirectPage}s which refer) to the stored \emph{RevisionRootPage}s. Based on the copy-on-write (COW) principle no data is lost with a minimum space consumption. Once a write transaction commits changes new \emph{NodePage}s containing modified nodes are persisted. NodePages which do not include changed nodes are not touched, therefore \emph{IndirectPage}s in subsequent revisions usually point to the same (persistent) data depending on the revisioning-strategy Treetank is configured to use.

\item[I/O] The I/O layer is responsible for persisting and retrieving data. Currently a BerkeleyDB binding as well as a memory mapped File binding is available. A binding to Cloud Storage providers through \emph{JClouds} is in development.
\end{description}

This architecture supports \emph{Snapshot-Isolation} through Multiversion Concurrency Control (MVCC) based on the page- and transaction-layer. Furthermore the well known ACID properties are supported. While importing large XMark-instances \cite{XMark} which are commonly used for benchmarking we encountered a space-overhead due to our pointer based approach. Appendix \ref{sec::treetank} details a number of enhancements to the persistent storage made which came up during writing this theses and. Furthermore the  the ACID properties are briefly described together with a few new consistency constraints tailored to the XML storage.

Treetank does not provide deltas. The revisioning algorithms merge \emph{NodePage}s with the same unique ID together and override existing nodes with the latest version. Deleted nodes are introduced to guarantee the correctness during the merge-phase. The combination of NodePages relies on the specific revisioning algorithm. Thus, the merge-phase of NodePages usually refers to the latest full dump of all NodePages or the previous revision. As a direct consequence we are not ably to simply use the page-layer or a delta between consecutive revisions. However the introduction of hook-mechanisms in a future version of Treetank will facilitate the generation of deltas. As a result the differences between consecutive revisions will always reflect the update-operations. Yet, such a delta can not be used comparing other revisions.

One of the most interesting properties of Treetank for our purpose is the \emph{versioning}. The next section describes the implementation of the ID-less diff algorithm called FMSE, described in the last Chapter (\ref{sec::relwork}).

\subsection{ID-less diff-algorithm (FMSE) / Preprocessing}
Preprocessing of raw data is a major task in every data processing pipeline. Besides data specific preprocessing, databases/resources which do not evolve through the Java-API of Treetank have to be imported. Note that it is very common to simply dump full revisions of temporal data, thus most often no direct deltas are provided which just have to be applied to a base revision. Furthermore similar distinct trees have to be compared. Both types usually do not include unique node-IDs and therefore must be compared using tree-to-tree comparison heuristics which try to determine and match the most similar nodes/subtrees. %In subsequent steps unmatched nodes are either to edit unmatched nodes afterwards (insert/delete/move). Thus, to take full advantage of the decreased storage costs regarding revisioned data in Treetank as well as to use the subsequent ID-based difference-algorithm and the visualizations, first of all differences between the tree-structures have to be computed.

%As most tree-structures do not include unique node-identifiers a diff-algorithm which compares tree-structures based on predefined similarity measures,
The FMSE algorithm described in the last Chapter has been implemented. The Nodes are matched based on a bottom-up traversal searching for the LCS of matching nodes on each level. Predefined functions determine the similarity of nodes/subtrees as described in Chapter \ref{sec::relwork} and used by the LCS-algorithm to determine matches. Unmatched nodes on each level are furthermore examined for crossmatches (moves). The algorithm not only facilitates the analysis of temporal evolving tree-structures but also the comparison of similar distinct trees which might be based on a common base version. The reasons for choosing FMSE are based on three properties: (1) it has been proven to be successfully implemented a few times (specifically for XML-documents) \cite{xmldiff}, \cite{diffxml}, (2) it utilizes a move-operations and (3) supports applying edit-operations/changes during a single \emph{Levelorder} and a subsequent \emph{Preorder} traversal to delete all remaining unmatched once matching nodes have been determined by the predefined similarity measures. Therefore they are not saved in main memory for a subsequent move-detection or other state-based operations. To support the FMSE implementation Treetank has been enhanced in several ways. The following new operators/methods and components have been developed:

\begin{itemize}
\item \texttt{LevelOrderAxis} which incorporates attribute- and namespace-nodes if desired.
\item \texttt{copy-operation} to copy nodes/subtrees of other \emph{database/resource}-tuples.
\item \texttt{move-operation} to move nodes/subtrees in the currently opened \emph{resource}.
\item \texttt{replace-operation} to replace a node and its subtree with another node/subtree.
\item Visitor pattern support for nodes/transactions.
\item Merging or avoidance of adjacent text nodes.
\end{itemize}

The \texttt{LevelOrderAxis} is described in algorithm \ref{levelOrderAxis}. Just like other axis to traverse certain regions or the whole tree-structure in Treetank it is based on the \texttt{Iterator/Iterable} Java interfaces to support the \texttt{foreach}-loop and iteration. All other axis have been extended as described in appendix\ref{sec::treetank}. \emph{mFirstChilds} is a double ended queue to remember all first childs from every right sibling for a subsequent new depth (depth + 1). \texttt{processElement()} is invoked to add non structural nodes, that is \texttt{attributes} and \texttt{namespaces} to the queue. After initialisation the queue is empty and \emph{mNextKey} is initialized to either the current key (if self is included), the right sibling node key if there is one or the first child node key. The NULL\_NODE\_KEY is a special node key to denote that the traversal is done.

\begin{algorithm}[Hhtbp]
%\SetAlgoLined
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
\Input{instance variables (denoted by a trailing "m")}
\Output{node key of next node}
\BlankLine
\If{getNext()}{
  return true\;
}
  
resetToLastKey()\;

\tcp{Setup.}
INodeReadTrx rtx $\leftarrow$ getTransaction()\;
IStructNode node $\leftarrow$ rtx.getStructuralNode()\;

\tcp{Determines if it is the first call to hasNext().}
\If{mFirst == true}{
  mFirst $\leftarrow$ false\;
  return processFirstCall()\;
}

\tcp{Follow right sibling if there is one.}
\If{node.hasRightSibling()}{
  processElement()\;
  \tcp{Add first child to queue.}
  \If{node.hasFirstChild()}{
    mFirstChilds.add(node.getFirstChildKey())\;
  }
  mKey $\leftarrow$ node.getRightSiblingKey()\;
  return true\;
}

\tcp{Iterate over non structural nodes (attributes/namespaces).} 
\If{mInclude == EInclude.NONSTRUCTURAL}{
  processElement()\;
}
\tcp{Add first child to queue.}
\If{node.hasFirstChild()}{
  mFirstChilds.add(node.getFirstChildKey())\;
}

\tcp{Then follow first child on stack.}
\If{!mFirstChildKeyList.isEmpty()}{
  mKey $\leftarrow$ mFirstChilds.removeFirst()\;
  return true\;
}

\tcp{Then follow first child if there is one.}
\If{node.hasFirstChild()}{
  mKey $\leftarrow$ node.getFirstChildKey()\;
  return true\;
}

\tcp{Then end.}
resetToStartKey()\;
return false\;
\caption{LevelOrderAxis (hasNext())}\label{levelOrderAxis}
\end{algorithm}

The \texttt{copy}-operation adds the capability to add whole subtrees of another \emph{database/resource} tuple to the currently opened \emph{resource}. Therefore and to support
many different kinds of operations depending on different node kinds the visitor pattern is used. Every node accepts a visitor whereas through double dispatching the appropriate method with the node instance itself as parameter is called.

Actually two \texttt{copy}-operations exist. Either the subtree is inserted as \texttt{first\-Child} or as \texttt{rightSibling} of the currently selected node. The node to copy must be a structural node, that is either an \texttt{ElementNode} or a \texttt{TextNode}. In case of a \texttt{DocumentRootNode} the read transaction has to move to the first child in the first place.

Algorithm \ref{visitTextNode} describes how a \texttt{TextNode} is handled. A bit more interesting is how \texttt{ElementNode}s are handled (algorithm \ref{visitElementNode}). The algorithm recursively calls itself to copy the whole subtree. To be sure it copies only the subtree and no other nodes in document order, the depth must be at all times $>$ 0 except for the first root-node to insert.

Note that the visitor implementation is not tail-recursive, therefore can not make use of tail call optimizations for self-recursive functions in the JVM, but the amount of nodes nontheless must be relatively small as the longest common subsequence routine .

\begin{algorithm}[Hhtbp]
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
\Input{instance variables (denoted by a trailing "m"), TextNode pNode}
\Output{void (none)}
\BlankLine
mRtx.moveTo(pNode.getNodeKey())\;
mInsert.insertNode(mWtx, mRtx)\;

\If{!mFirst $and$ mRtx.getStructuralNode().hasRightSibling()}{
  mRtx.moveToRightSibling()\;
  mInsert $\leftarrow$ EInsert.ASRIGHTSIBLING\;
  mRtx.getNode().acceptVisitor(this)\;
}\ElseIf{!mFirst}{
  insertNextNode();
}
\caption{visitNode(TextNode pNode))}\label{visitTextNode}
\end{algorithm}

\begin{algorithm}[Hhtbp]
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
\Input{instance variables (denoted by a trailing "m"), ElementNode pNode}
\Output{void (none)}
\BlankLine
mRtx.moveTo(pNode.getNodeKey())\;
mInsert.insertNode(mWtx, mRtx)\;
mInsert $\leftarrow$ EInsert.ASNONSTRUCTURAL\;

\For{int i $\leftarrow$ 0, nspCount $\leftarrow$ pNode.getNamespaceCount(); i $<$ nspCount; i++}{
  mRtx.moveToNamespace(i)\;
  mInsert.insertNode(mWtx, mRtx)\;
  mRtx.moveToParent()\;
}

\For{int i $\leftarrow$ 0, attrCount $\leftarrow$ pNode.getAttributeCount(); i $<$ attrCount; i++}{
  mRtx.moveToAttribute(i)\;
  mInsert.insertNode(mWtx, mRtx)\;
  mRtx.moveToParent()\;
}

\If{pNode.hasFirstChild()}{
  mFirst $\leftarrow$ false\;
  mInsert $\leftarrow$ EInsert.ASFIRSTCHILD\;
  mRtx.moveToFirstChild()\;
  mDepth+=1\;
  mRtx.getNode().acceptVisitor(this)\;
}\ElseIf{!mFirst $and$ paramNode.hasRightSibling()}{
  mInsert $\leftarrow$ EInsert.ASRIGHTSIBLING\;
  mRtx.moveToRightSibling()\;
  mRtx.getNode().acceptVisitor(this)\;
}\ElseIf{!mFirst}{
  insertNextNode()\;
}
\caption{visitNode(ElementNode pNode))}\label{visitElementNode}
\end{algorithm}

\begin{algorithm}[Hhtbp]
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
\Input{instance variables (denoted by a trailing "m")}
\Output{void (none)}
\BlankLine
\While{!mRtx.getStructuralNode().hasRightSibling() and mDepth $>$ 0}{
  mRtx.moveToParent()\;
  mWtx.moveToParent()\;
  mDepth-=1\;
}

\If{Depth $>$ 0}{
  mInsert $\leftarrow$ EInsert.ASRIGHTSIBLING\;
  \If{mRtx.getStructuralNode().hasRightSibling()}{
    mRtx.moveToRightSibling()\;
    mRtx.getNode().acceptVisitor(this)\;
  }
}
\caption{insertNextNode()}\label{insertNextNode}
\end{algorithm}

The \texttt{move-} operation like the \texttt{copy-} operation is implemented in two different versions, \texttt{moveSubtreeToFirstChild(long)} and \\\texttt{moveSubtreeToRightSibling(long)}. The only parameter is the unique node ID of a node to move along with its descendants, the node key.

We examine both operations independently as they require different node manipulations of neighbour nodes including the new and old parent node and the first child node. Both operations are defined in terms of moving structural- and non-structural nodes (the latter in subtrees of the moved node), whereas the root-node to move must be a structural node.

First, the following constraints are checked:

\begin{itemize}
\item The node/subtree to move must be an \texttt{element}- or a \texttt{text}-node.
\item It is not permitted to move a node to one of its descendants which would introduce , therefore it is checked if the node to move is one of the ancestors of the anchor node.
\end{itemize}

The two operation require the following node manipulations. The location the node is moved away is subject to the following changes:
\begin{itemize}
\item In case of \texttt{moveSubtreeToFirstChild(long)}: Parent node must point to the right sibling node key of the current node if it was the first child.
\item Decrement child count of parent node.
\item Collapse text nodes if both the left- and right- sibling are text nodes, therefore remove the right node and append its value to the left sibling. Furthermore adapt its right sibling pointer to the former right sibling of the right sibling text node which has been deleted.
\item If no text node collapsing involved: adapt right sibling key of former left sibling to the right sibling key of the moved node provided one exists.
\item If no text node collapsing involved: adapt left sibling key of former right sibling to the left sibling key of the moved node provided one exists.
\end{itemize}

The node to which the new subtree is inserted is subject to the following changes. \\
In case of \texttt{moveSubtreeToFirstChild(long)}:
\begin{itemize}
\item Increment the child counter of the node to which the new subtree is inserted.
\item Adapt the first child key of the node to which this node is inserted to point to the new node.
\item Adapt the left sibling pointer of the former first child to the root node of the inserted subtree.
\end{itemize}

In case of \texttt{moveSubtreeToRightSibling(long)}:
\begin{itemize}
\item Increment the child counter of the parent node.
\item Adapt the right sibling key to the nodeKey of the moved node.
\end{itemize}

The node which is moved is changed in the following ways. \\In case of \texttt{moveSubtreeToFirstChild(long)}:
\begin{itemize}
\item Adapt the left sibling pointer to \texttt{NULL\_NODE\_KEY}.
\item Adapt the right sibling pointer to the former first child of the node to which this node is inserted or \texttt{NULL\_NODE\_KEY} if there was not one.
\item Adapt the parent pointer to point to the node to which this node is inserted.
\end{itemize}

In case of \texttt{moveSubtreeToRightSibling(long)}:
\begin{itemize}
\item Adapt the left sibling pointer to the nodeKey of the node where this node is inserted.
\item Adapt the right sibling pointer to the right sibling key of the node where this node is inserted.
\end{itemize}
% import of network data

Besides the added \texttt{move}-operations the \texttt{delete}-operation has been modified to merge adjacent text nodes with a single whitespace after a delete \ref{deletes} to adhere to the XPath/XQuery Data Model (XDM). \texttt{insert}-operations as of now check if the new \texttt{TextNode} would yield two consecutive TextNodes and, if so, updates the value with a concatenation of the old- and new-values instead. Therefore the storage consistently avoids two consecutive \texttt{TextNode}s. 

Having described the preliminaries the next section describes the FMSE implementation itself.

\subsubsection{FMSE} The FMSE implementation first saves node-types and the according node-IDs in two maps during a postorder traversal. Next, the algorithm determines a longest common subsequence of matching nodes. Leaf nodes are compared first, then inner nodes. Thus the inorder-traversal described in \cite{chawathe1996change} must be replaced by a postorder-traversal. Otherwise some leaf nodes are not processed beforehand which are required to determine the similarity of inner nodes. The matching of nodes involves two different similarity-metrics as described in the last chapter. However our implementation requires some explanation, as the matching is crucial and the changes applied by FMSE are propagated to a subsequent ID-based diff-algorithm:

\begin{itemize}
\item \texttt{TextNode}s are matched based on their String-value. The Levenshtein\-algo\-rithm is used to compute a similarity measure of the values, which counts update costs of individual characters normalized between 0 and 1. QNames of \texttt{Namespace}- and \texttt{attribute}-nodes are matched first based on equality. In case of attributes afterwards their value is compared yet again using the Levenshtein-algorithm in addition to their ancestor-elements.

\item \texttt{ElementNode}s are compared based on the number of matched nodes in their subtree. Recapitulate that all node-types are chained for the fast\-Matching-algorithm bottom up during a postorder traversal. Empty elements however are compared based on their \texttt{QName} similarity, whereas all ancestor nodes are also compared once more using Levenshtein. This ensures the possibility of matching empty-elements after a deletion or insertion of a subtree. Treating empty nodes as leaf nodes otherwise will prohibit matching empty \texttt{element}-nodes with other \texttt{element}-nodes which include a subtree because leaf nodes and internal nodes are compared in different successive steps and thus not cross-compared. Matching nodes are stored in a \texttt{BiMap} containing forward and backward matchings of nodeKeys.
\end{itemize}

After storing matching node-IDs, FMSE step one is implemented straight forward. However whenever an \texttt{attribute}- or \texttt{namespace}-node is determined to be moved it is deleted from the old parent and inserted at the new parent node as we do not permit moves of these node-types. Another noteworthy subject regarding moves is, that deleted text nodes in case adjacent nodes are collapsed must be removed from the mapping as well. Due to adding the consistency constraint that \emph{never}, before and after a commit, duplicate attributes with the same \texttt{QName} are permitted, a new attribute value is set in the \texttt{WriteTransaction.insertAttribute(QName, String)} method instead of adding a new one if the \texttt{QName} of the node to insert is identical to another attribute-node with the same parent. This case occurs whenever the attributes with the same \texttt{QName} are not matched. All updated or inserted nodes are added to the matches as described in the paper to prevent them from deletion in the next step.

The second FMSE step, which deletes non matching nodes with their whole subtrees, involves a preorder traversal of the tree. Thus a new \\\texttt{VisitorDescendantAxis} which optionally expects a visitor instance is implemented \footnote{Visitors are always preferable to other methods if algorithms depend on the specific node-types, due to runtime errors during downcasts or possibly long chains of \texttt{instanceof} checks}. The axis executes a visitor specific implementation for each visited node. The return value of the methods the visitor has to implement (a visitor specific implementation for each node-type) guides the traversal in the axis. The following result types are currently available:

\begin{itemize}
\item \texttt{EVisitResult.TERMINATE}, terminates the traversal of the (sub)tree immediately and returns false for upcoming \texttt{hasNext()} calls.
\item \texttt{EVisitResult.CONTINUE}, continues preorder traversal.
\item \texttt{EVisitResult.SKIPSUBTREE}, signales that the axis skips traversing the subtree of the current node.
\item \texttt{EVisitResult.SKIPSIBLINGS}, signales that the axis should move to the next following node in document order which is not a right-sibling of the current node.
\item \texttt{EVisitResult.POPSKIPSIBLINGS}, is a special type which signals that the element on top of the internal right sibling stack must be popped, which is needed to implement for instance the deletion-visitor for the second FMSE-step.
\end{itemize}

An implementation must implement a \texttt{EVisitResult visiNode(NodeType pNode)} for each node type. The deletion-visitor implementation of the method \texttt{EVisitResult visitNode(ElementNode pNode)} is described in algorithm \ref{visitElementNode}. Note that all \texttt{attribute}- and \texttt{namespace}-nodes, which are going to be deleted, must be saved in a sequence. Afterwards they have to be deleted through a sequence traversal. If the nodes instead are deleted in place the \texttt{attribute}- and/or \texttt{namespace}-counter of the parent \texttt{element}-node is decreased immediately and possibly unmatched nodes with the highest index(es) are not going to be deleted. The \texttt{delete(INode)} method described in \ref{deleteNode} deletes the element node along with all its \texttt{attribute}- and \texttt{namespace}-nodes as well as its subtree. During the removal of a structural node (\texttt{element}- or \texttt{text}- node) and its subtree the transaction is either moved to the right sibling of the deleted node, to the left sibling or to the parent, if it exists in the order described. Note that the parent must exist. Treetank moves the transaction either to the right-sibling of the current node to delete if it exists, to the left-sibling if it exists or to the parent node in the given order. For the simple reason that the  transaction is moved to the next node in preorder after invoking the visitor which actually deletes a node, the transaction must be moved to the last node in the \texttt{previous::} axis. Otherwise it will be moved by the remove-operation in the first place \emph{and} the axis subsequently. The \texttt{VisitorDescendantAxis} moves the transaction to the next node in preorder afterwards. The movement is determined and executed after the deletion of the \texttt{element}-node in the method \texttt{delete(pWtx, pNode)} outlined in algorithm \ref{deleteNode}.

\begin{algorithm}[Hhtbp]
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
\Input{WriteTransaction mWtx, Matching mMatching, long mStartKey, ElementNode pNode}
\Output{EVisitResult type}
\BlankLine
Long partner $\leftarrow$ mMatching.partner(pNode.getNodeKey())\;
\If{partner == null}{
  EVisitResult retVal $\leftarrow$ delete(mWtx, pNode)\;
  \If{pNode.getNodeKey() == mStartKey}{
    retVal = EVisitResult.TERMINATE\;
  }
  return retVal\;
}\Else{
  long nodeKey $\leftarrow$ pNode.getNodeKey()\;
  List$<$Long$>$ keysToDelete $\leftarrow$
                new ArrayList$<>$(pNode.getAttributeCount() + pNode.getNamespaceCount())\;
  \For{int i = 0; i $<$ pNode.getAttributeCount(); i++}{
    mWtx.moveToAttribute(i)\;
    long attNodeKey $\leftarrow$ mWtx.getNode().getNodeKey()\;
    \If{mMatching.partner(attNodeKey) == null}{
      keysToDelete.add(attNodeKey)\;
    }
    mWtx.moveTo(nodeKey)\;
  }
  \For{int i = 0; i $<$ pNode.getNamespaceCount(); i++}{
    mWtx.moveToNamespace(i)\;
    long namespNodeKey $\leftarrow$ mWtx.getNode().getNodeKey()\;
    \If{mMatching.partner(namespNodeKey) == null}{
      keysToDelete.add(namespNodeKey)\;
    }
    mWtx.moveTo(nodeKey)\;
  }

  \ForEach{long keyToDelete : keysToDelete}{
    mWtx.moveTo(keyToDelete)\;
    mWtx.remove()\;
  }

  mWtx.moveTo(nodeKey)\;
  return EVisitResult.CONTINUE\;
}
\caption{FMSEDeleteVisitor: EVisitResult visit(ElementNode pNode)}\label{visitElementNode}
\end{algorithm}

\begin{algorithm}[Hhtbp]
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
\Input{NodeWriteTrx pWtx, ElementNode pNode}
\Output{EVisitResult type}
\BlankLine
long nodeKey $\leftarrow$ pWtx.getNode().getNodeKey()\;
boolean removeTextNode $\leftarrow$ checkIfTextNodeRemove()\;
\tcp{Case: Has no right and no left sibl. but the parent has a right sibl.}
pWtx.moveToParent()\;
IStructNode node = pWtx.getStructuralNode()\;
\If{node.getChildCount() == 1 AND node.hasRightSibling()}{
  pWtx.moveTo(nodeKey)\;
  pWtx.remove()\;
  return EVisitResult.SKIPSUBTREEPOPSTACK\;
}
pWtx.moveTo(nodeKey)\;
\tcp{Case: Has left sibl. but no right sibl.}
\If{!pWtx.getStructuralNode().hasRightSibling() AND pWtx.getStructuralNode().hasLeftSibling()}{
  pWtx.remove()\;
  return EVisitResult.CONTINUE\;
}
\tcp{Case: Has right sibl. and left sibl.}
\If{pWtx.getStructuralNode().hasRightSibling() AND pWtx.getStructuralNode().hasLeftSibling()}{
  \If{removeTextNode}{
    pWtx.moveToRightSibling()\;
    \If{pWtx.getStructuralNode().hasRightSibling()}{
      pWtx.moveToLeftSibling()\;
      pWtx.remove()\;
      pWtx.moveToLeftSibling()\;
      return EVisitResult.SKIPSUBTREE\;
    }\Else{
      pWtx.moveToLeftSibling()\;
      pWtx.remove()\;
      return EVisitResult.CONTINUE\;
    }
  }\Else{
    pWtx.remove()\;
    pWtx.moveToLeftSibling()\;
    return EVisitResult.SKIPSUBTREE\;
  }
}
\tcp{Case: Has right sibl. but no left sibl.}
\If{pWtx.getStructuralNode().hasRightSibling() AND !pWtx.getStructuralNode().hasLeftSibling()}{
  \tcp{similar to above case (omitted)}
}
\tcp{Case: Has no right and no left sibl.}
mWtx.remove()\;
return EVisitResult.CONTINUE\;
\caption{FMSEDeleteVisitor: delete(pWtx, pNode)}\label{deleteNode}
\end{algorithm}

\subsection{ID-based diff}
Once revisioned data is imported or a database/resource has evolved using the Treetank Java-API in the first place the main task is to reveal and present structural differences of the tree-structures. Treetank supports collections. A database includes one or more resources. Due to stable unique node IDs in each resource we import every kind of tree-structure, even similar distinct tree-structures as consecutive revisions. Otherwise using separate resources it will not be possible to use a fast ID-based diff-algorithm. Different resources do not share unique node-IDs. 

Thus Treetank has to support an ID-based diff-algorithm between two revisions. Note that the algorithm is designed to be able to compare any two revisions. It compares two nodes each time and determines the type of diff. Fig. \ref{fig:diff} illustrates a simple example with edit-operations using Treetank. The edit-operations might be part of invoking an import of the differences between two trees determined by our FMSE-implementation or by using the Treetank transaction Java-API either directly or indirectly via triggers.

\begin{figure}[tb]
\center{\includegraphics[width=\textwidth]
{figures/diff}}
\caption{\label{fig:diff} Two revisions of a tree-structure and the edit-operations involved. By comparing consecutive revisions the edit-operations usually equal the diff-types considering \texttt{REPLACEDOLD/REPLACEDNEW} as one operation just like \texttt{MOVEDFROM/MOVEDTO}.}
\end{figure} 

\subsubsection{Hashes} One of our goals is the efficiency of our approach as it has to be usable within interactive visualizations. Meantioned briefly in the storage section hashes of the nodes can be used to skip traversal of subtrees. They are build incrementally based on the nodes in the subtree bottom up either during a postorder traversal or on the fly. The postorder-traversal to build hashes is a new subtree-insertion method to minimize the affected nodes and reduce the asymptotic bound from $O(n^2)$ to $O(n)$. Two kinds of hashes are available, rolling hashes and postorder hashes. \emph{Rolling} hashes only affect nodes on the ancestor axis whereas \emph{postorder} hashes also affect nodes in a postorder traversal starting at the current node. Whenever identical hashes are determined the nodes are matched and the two transactions which compute the diff can move to the next node in document order, which is not a descendant of the current node. Thus the transactions move to the next node in the XPath \texttt{following::}-axis. Hence, whole subtrees can be skipped. The hashes include the unique node-IDs as well as node specific content. The hash-method is designed to be fast and to reduce collisions to a minimum. Even if hash-collisions which are extremely unlikely appear it is not possible to match subtrees with same hash-values as the node-IDs are also compared which are stable and unique during all revisions. Rolling-hashes are enabled by default during the database/resource creation and optionally used by our diff-algorithm. It is for instance used by an optional pruning of the tree in a Sunburst-layout to speed up the computation as well as the construction of the visualization. An in depth explanation of this application is provided in the Chapter \ref{sec::visualizations}. The next subsection briefly described two modes of the algorithm.

\subsubsection{Kind of differences} Interested observers are notified of the diff between two nodes through registration and the implementation of a special interface method. Currently two kinds of diffs can be computed.

\begin{itemize}
\item \emph{Structural Diff} calculates changes without comparing attribute and namespace nodes. This implies that whenever the overall structure is crucial this algorithm should be chosen.
\item \emph{Full Diff} takes structural nodes as well as attribute and namespace nodes into account. However currently we do not emit non-structural changes. Changes in \texttt{namespace}- or \texttt{attribute}-nodes results in an \texttt{UPDATED} parent-element. This restriction applies as the \emph{SunburstView} which is described in Chapter \ref{sec::visualizations} currently does not include special \texttt{namespace}- or \texttt{attribute}-items. Instead these are part of the element item and shown on mouseover.
\end{itemize}
They are implemented by a simple template method\\ \texttt{checkNode(IReadTransaction, IReadTransaction)} which is called by the basic diff-algorithm.

The following diff-types are supported by the algorithm:

\begin{itemize}
\item \texttt{INSERTED} denotes that a node has been inserted.
\item \texttt{DELETED} denotes that a node has been removed.
\item \texttt{UPDATED} denotes that a node has been updated, that is either the QName of an \texttt{element}-node has been updated or the value of a \texttt{text}-node.
\item \texttt{SAME} denotes that a node has not changed.
\item \texttt{REPLACEDOLD} denotes that a node or subtree has been replaced (the old node/subtree).
\item \texttt{REPLACEDNEW} denotes that a node or subtree has been replaced (the new node/subtree).
\end{itemize}

Note that the differentiation between \texttt{REPLACEDOLD/REPLACEDNEW} is to support an aggregated tree-structure as an underlying model of the visualizations. Two other diff-types are supported by an optional post-processing step.

\begin{itemize}
\item \texttt{MOVEDFROM} denotes that a node or whole subtree has been moved from this location to another one.
\item \texttt{MOVEDTO} denotes that a node or whole subtree has been moved to this location.
\end{itemize}

The types are splitted, too to indicate the movemenet of the node, the old place as well as the new place in the aggregated tree-structure.

\subsection{Traversal of both revisions}
The algorithm to traverse the trees and to compute the differences between two nodes in each revision is depicted in algorithm \ref{overallDiffAlgo}. First, the method\\ \texttt{treeDeletedOrInserted(IReadTransaction, IReadTransaction)} checks if\\ both transactions opened on each revision can be moved to the start node. If not, either \texttt{DiffType.INSERTED} or \texttt{DiffType.DELETED} has to be emitted for each node of one of the revisions depending on the transaction which could not be moved.

Let's examine both cases:
\begin{itemize}
\item
The transaction opened on the older revision can not be moved to the start node. This implies that the tree in the new revision has been inserted.
\item
The transaction opened on the newer revision can not be moved to the start node. This implies that all nodes in the old transaction have been deleted.
\end{itemize}

The distinction is used to support the visualizations which are going to be described in Chapter \ref{sec::visualizations} and only affects subtrees. Otherwise simply put all nodes in the old revision must have been deleted, whereas all nodes in the new revision have been inserted.

After that the transactions are moved forward in \emph{document order} depending on the last encountered kind of diff between two nodes. Document order is identical to a preorder traversal of a tree. In case of an insert, the transaction opened on the new revision is moved forward, in case of a delete the transaction opened on the old revision is moved (the \\ \texttt{moveCursor(IReadTransaction, ERevision)}-method). If a node is updated or has not been changed at all both transactions move to the next node in document order. Once the traversal in one of the two revisions is done, the transaction is located at the document root. The diff-calculation ends if either the transaction on the older revision is located at the document root and the last encountered diff kind was \texttt{DELETED} or both transactions are located at the document-root of both revisions. Note that if the transaction on the newer revision is located at the document root, but the transaction on the old revision is not the following nodes have been \texttt{DELETED} at the end of the tree and must be emitted as such (lines 22-28). 

\begin{algorithm}[Hhtbp]
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
\Input{instance variables (denoted by a trailing "m") (HashKind mHashKind, long pOldRevKey, long pNewRevKey, long mOldStartKey, long mNewStartKey, DiffType pDiffType, DiffTypeOptimized mDiffKind, ISession mSession}
\Output{for each node comparsion: DiffType diffType, IStructNode oldNode, IStructNode newNode, Depth depth}
\BlankLine
INodeReadTransaction rtxOld $\leftarrow$ mSession.beginNodeReadTransaction(pOldRevKey)\;
INodeReadTransaction rtxNew $\leftarrow$ mSession.beginNodeReadTransaction(pNewRevKey)\;
\tcp{moveTo(long) returns true in case the transaction could be moved to the node or false otherwise.}
newRtxMoved $\leftarrow$ rtxNew.moveTo(mNewStartKey)\;
oldRtxMoved $\leftarrow$ rtxOld.moveTo(mOldStartKey)\;

treeDeletedOrInserted(newRtxMoved, oldRtxMoved)\;

DiffType $\leftarrow$ null\;
\tcp{Check first node.}
\If{mHashKind == HashKind.None OR mDiffKind == DiffTypeOptimized.NO}{
  diff $\leftarrow$ diff(rtxNew, rtxOld, depth)\;
}\Else{
  diff $\leftarrow$ optimizedDiff(rtxNew, rtxOld, depth)\;
}

\tcp{Iterate over new revision (order of operators significant -- regarding the OR).}
\If{diff != DiffType.SAMEHASH}{
  \While{(rtxOld.getNode().getKind() != ENode.ROOT\_KIND AND diff == DiffType.DELETED) OR moveCursor(rtxNew, ERevision.NEW)}{
  \If{diff != DiffType.INSERTED}{
    moveCursor(rtxOld, ERevision.OLD)\;
  }

  \If{rtxNew.getNode().getKind() != ENode.ROOT\_KIND
   or rtxOld.getNode().getKind() != ENode.ROOT\_KIND}{
    \If{mHashKind == HashKind.None OR mDiffKind == DiffTypeOptimized.NO}{
      diff $\leftarrow$ diff(rtxNew, rtxOld, depth)\;
    }\Else{
      diff $\leftarrow$ optimizedDiff(rtxNew, rtxOld, depth)\;
    }
  }
}

\tcp{Nodes deleted in old rev at the end of the tree.}
\If{rtxOld.getNode().getKind() != ENode.ROOT\_KIND}{
  emitOldNodes(rtxNew, rtxOld, depth)\;
}
}

done()\;
\caption{ID-based diff: traversal}\label{overallDiffAlgo}
\end{algorithm}

\subsection{Diff-Computation}
Besides moving both transactions forward in document-order depending on the type of diff the computation which determines the diff-type itself is crucial. The computation is the main task of the \\ \texttt{diff(INodeReadTransaction, INodeReadTransaction, Depth)}-method outlined in algorithm \ref{diffAlgo}. It is invoked whenever the nodeKeys or the \texttt{QName}s/\texttt{Text}-values of the nodes to compare differ.

\begin{algorithm}[Hhtbp]
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
\Input{Depth pDepth, INodeReadTrx pOldRtx, INodeReadTrx pNewRtx}
\Output{kind of diff (DiffType enum value)}
\BlankLine
DiffType diff $\leftarrow$ DiffType.SAME;

\tcp{Check if node has been deleted.}
\If{pDepth.getOldDepth() $>$ pDepth.getNewDepth())}{ 
  diff $\leftarrow$ DiffType.DELETED\;
  cumulatDiffTypes(diff)\;
  \If{checkReplace(pNewRtx, pOldRtx)}{
        diff $\leftarrow$ DiffType.REPLACED\;
  }
}\tcp{Check if node has been updated.}\ElseIf{checkUpdate(pNewRtx, pOldRtx)}{ 
  diff $\leftarrow$ DiffType.UPDATED\;
}\tcp{Check if node has been replaced.}\ElseIf{checkReplace(pNewRtx, pOldRtx)}{ 
  diff $\leftarrow$ DiffType.REPLACED\;
}\Else{
  long oldKey $\leftarrow$ pOldRtx.getNode().getNodeKey()\;
  boolean movedOld $\leftarrow$ pOldRtx.moveTo(pNewRtx.getNode().getNodeKey())\;
  pOldRtx.moveTo(oldKey);

  long newKey $\leftarrow$ pNewRtx.getNode().getNodeKey()\;
  boolean movedNew $\leftarrow$ pNewRtx.moveTo(pOldRtx.getNode().getNodeKey())\;
  pNewRtx.moveTo(newKey);

  \If{!movedOld}{
    diff $\leftarrow$ DiffType.INSERTED\;
  }\ElseIf{!movedNew}{
    diff $\leftarrow$ DiffType.DELETED\;
  }\Else{
    \tcp{Determine if one of the right sibling matches.}
    EFoundEqualNode found $\leftarrow$ EFoundEqualNode.FALSE\;
    long key $\leftarrow$ pOldRtx.getNode().getNodeKey()\;

    \While{pOldRtx.getStructuralNode().hasRightSibling() AND pOldRtx.moveToRightSibling()
      AND found == EFoundEqualNode.FALSE}{
      \If{checkNodes(pNewRtx, pOldRtx)}{
        found $\leftarrow$ EFoundEqualNode.TRUE\;
        break\;
      }
    }

    pOldRtx.moveTo(key)\;
    diff $\leftarrow$ found.kindOfDiff()\;
  }

  cumulatDiffTypes(diff)\;
}

return diff\;
\caption{ID-based diff: diff-computation}\label{diffAlgo}
\end{algorithm}

First, the depths of the nodes have to be compared. The depth is the sum of nodes in the path up to the root-node. When the depth of the node in the old revision is greater than the depth of the node in the new revision it must have been deleted. Note that the depths are not persisted, thus counters have to keep track of the current depths. All diff-tuples which are of type \texttt{DiffType.DELETED} or \texttt{DiffType.INSERTED} are saved in a Java \texttt{List}. A second datastructure is used to gather the diff types itself, that is a whole subtree which is either inserted or deleted is cumulated by the according diff-type. This datastructure is used to find \texttt{INSERTED}, \texttt{DELETED} combinations which are instead emitted as of type \texttt{DiffType.REPLACEDOLD} (the deleted tuples) and \texttt{DiffType.REPLACENEW} (the inserted tuples).

When the depth of the node in the old- and the node in the new-revision instead either is identical or the depth of the node in the more recent revision is greater at first the node is checked for an update through comparison of the nodeKeys and the depths of the nodes. Unless the check succeeds and thus yields true the nodes are examined for replacement. Therefore the datastructure which keeps track of deleted- and inserted-subtrees is reviewed. Consecutive insert/delete- or insert/insert/delete/delete-tuples are emitted as replaced subtrees. Note that this replace-detection is just a simple heuristic and currently does only detect the aforemeantioned pairs of inserted and deleted nodes.%The datastructure in either case is emptied even if no matching types are found. Furthermore when two diff-types previously have been stored in the datastructure the \texttt{List} of diff-tuples must immediately be emitted in case a replace has been detected and the datastructure must be reinitialized \footnote{for instance replaced with a new instance} afterwards. Four elements are always immediately emitted regardless of whether the diff-types have changed or not. In the first case subsequently the replaced tuples must be emitted.

Assuming a node or subtree has not been replaced, it must be decided if the current node in the new revision is inserted or the current node in the old revision is deleted. First, it is determined if the transaction opened on the old revision can be moved to the current node in the new revision. If not it is immediately obvious that the node has been inserted. Otherwise, if the transaction opended on the new revision can \emph{not} be moved to the current node in the old revision it must be a deleted node. For the simple reason that move-operations are supported both checks might succeed. In this case the right siblings of the node in the old revision have to be examined in order to determine the type of diff until one of them matches the node in the new revision, that is the node-IDs are identical or no more right siblings are available. In the first case the new node must be inserted. Otherwise it must be deleted.

\subsection{Detecting moves}
An optional postprocessing step is required to detect moves. The two basic diff-types \texttt{MOVEDFROM} and \texttt{MOVEDTO} are detected after all operations have been emitted. The detection requires three datastructures to store all diff-types, the inserted nodes and the deleted nodes.

\subsubsection{Impossible to detect moves on the fly} Note that it is not possible to include the detection of moves in the preorder-traversal of both revisions itself, as it is not known which of the two nodes is the one which has been moved and which one is the node which is unchanged. However this is required to determine which of the two transactions must be moved to the next node in document order. All we can argue is, that it would be possible to detect a move itself if the transaction on the new revision can be moved to the current node from the transaction in the old revision and vice versa. That is all \texttt{DELETED} or \texttt{INSERTED} nodes have already been emitted, meaning that one of the two nodes which are currently compared must have been moved and the other must have been unchanged constant. It is not possible to decide which one of the two nodes stayed the same and which one has been moved. The position in the tree is no implication wheter a node has been moved from or moved to another place, but this is crucial to decide which of the two nodes has not changed and which one actually has been moved. As thus the types have to be matched. Whenever the unique nodeKey of a \texttt{DELETED}-node matches the key of an \texttt{INSERTED}-node, the corresponding diff-types can be changed into \texttt{MOVEDFROM} and \texttt{MOVEDTO}. The next subsection details a postprocessing algorithm which is based on this idea.

\subsubsection{Detection of moves in a postprocessing step} All encountered diff-types are saved in an associative array, a map (index of their encounter $\Leftrightarrow$ diff-tuple) \footnote{which is used just like a List, to switch between a map implementation based on a persistent  BerkeleyDB database depending on a specified threshold value or a simple LinkedHashMap instance} in preorder which is the order in which they have been observed. Additionally \texttt{DELETED} and \texttt{INSERTED} nodes are recorded mapping their unique nodeKey to the index in the original map with all entries. The algorithm described in \ref{diffPostprocessing} expects the three maps. It tries to match \texttt{INSERTED} $\Leftrightarrow$ \texttt{DELETED} pairs and vice versa and checks whether the diffType in the map needs to be adjusted to \texttt{MOVEDTO} or \texttt{MOVEDFROM} (or not at all). A map which does not contain a value for the specified key returns the special value \texttt{null}. First, the old nodeKey (might have been deleted) is searched for in the Map containing all inserted tuples. If the key is found (value $!=$ null) the type is checked. If the current diff-tuple is of type \texttt{DELETED} or \texttt{MOVEDFROM} the diff type is set to \texttt{MOVEDTO}. Note that the check for the \texttt{MOVEDFROM} type is necessary as the corresponding \texttt{INSERT} tuple might have been encountered before and thus the type has been changed to \texttt{MOVEDFROM} already. The following is the inverse case to set the \texttt{MOVEDFROM} type if necessary. Furthermore a link in the form of the index of the matching node with the same nodeKey and the corresponding \texttt{MOVEDTO} diff-type is additionaly saved. Note that the algorithm does not detect \texttt{text}-nodes which are moved to a right sibling of another \texttt{text}-node. In this case our implementation of the \texttt{moveSubtreeToRightSibling(long)} prepends the value of the current \texttt{text}-node to the moved \texttt{text}-node and subsequently deletes the current node. This ensures, that no two text-nodes are ever adjacent which otherwise contradicts the XQuery/XPath data model (XDM). In this particular edge case the algorithm determines a \texttt{REPLACED} node (a direct consequent from the deletion of the node the transaction resides at and the insertion of the moved node with the prepended text-value) and a \texttt{DELETED} node (the node which has been moved).

\begin{algorithm}[Hhtbp]
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
\Input{Map allDiffs, Map inserted, Map deleted}
\Output{none (void)}
\BlankLine
\tcp{For every diff tuple in the map which saves all encountered diffs in document-order}
\For{Diff diffTuple : allDiffs.values()}{
  Integer newIndex $\leftarrow$ inserted.get(diffTuple.getOldNodeKey())\;
  \If{newIndex != null
    AND (diffTuple.getDiff() == DiffType.DELETED OR diffTuple.getDiff() == DiffType.MOVEDFROM)}{
      allDiffs.get(newIndex).setDiff(DiffType.MOVEDTO)\;
  }
  Integer oldIndex $\leftarrow$ deleted.get(diffCont.getNewNodeKey())\;
  \If{oldIndex != null
    AND (diffTuple.getDiff() == DiffType.INSERTED OR diffTuple.getDiff() == DiffType.MOVEDPASTE)}{
      allDiffs.get(oldIndex).setDiff(DiffType.MOVEDFROM).setIndex(
                 inserted.get(diffTuple.getNewNodeKey()))\;
  }
}
\caption{ID-based diff: postprocessing to detect moves}\label{diffPostprocessing}
\end{algorithm}

\subsection{Runtime/Space analysis and scalability of the ID-based diffing algorithm}
The runtime of the ID-based diff algorithm is $O(n+m)$ whereas $n$ is the number of nodes in the first tree and $m$ the number of nodes in the second tree. It is thus a fast linear diff-computation in comparison to the FMSE-algorithm which is used in the first place to determine the differences which are imported. The space-consumption is $O(1)$ and in case the replace-operation is enabled at worst $O(k)$ whereas k is the sum of the subtrees which are cached (at most 4 subtrees currently). However the space consumption of an aggregated tree-structure which is going to be described in the next chapter (\ref{sec::visualizations}) is $O(u*k+v*k)$. $u$ is the number of unchanged nodes, $v$ is the number of changed nodes and $k$ is tuple relevant stuff (type of diff, the nodes and the depths in both trees). Thus the asymptotic space consumption is linear depending only on the number of unchanged and changed nodes.

Our performance evaluation involves measuring the scaling during different modification-loads (Fig. \ref{fig:100MBscaling}) and different document sizes with scaled modification-loads (Fig. \ref{fig:docScaling}). The modification-loads are increased in the same scale as the document size such that the documents are modified with approximately the same number of modifications. The hardware used is a common notebook with 4Gb RAM and a Core 2 Duo 2,66 Ghz CPU. Fig. \ref{fig:100MBscaling} shows that the number of modifications minimally affects the runtime. The runtime decreases linear as less modifications between two revisions have been made. However the linear decrease is minimal due to a few more checks.

\begin{figure}[tb]
\centering
\includegraphics[width=\textwidth]{figures/100MB-scaling}
\caption{Scaling during different modification-schemas (update/insert/delete/replace/move every 1000st, 5000st and 10000st node) in a 111 MiB XMark instance.} 
\label{fig:100MBscaling}
\end{figure}

\begin{table}[tb]
\centering 
\begin{tabular}[r]{|l|c|c|c|} 
\hline
& \textbf{1000mods} & \textbf{5000mods} & \textbf{10000mods}\\
\hline
\hline
\textbf{min} & 36265.14 & 35717.34 & 33948.96\\
\hline
\textbf{max} & 52459.38 & 61860.29 & 44451.06\\
\hline
\textbf{average} & 39167.75 & 37650.67 & 36579.37\\
\hline
\end{tabular}
\label{chap3:comparsion}
\vspace{0.5em} 
\caption{Comparsion of different modification-schemas of a 111 MiB XMark instance (update/insert/delete/replace/move every 1000st, 5000st and 10000st node). Runtime in ms.}
\end{table}

Fig. \ref{fig:docScaling} depicts the scaling during different document sizes and modification numbers. The scale is logarithmic, thus we are able to identify the linear runtime due to increased document sizes. It therefore emphasizes the asymptotic bound.

\begin{figure}[tb]
\centering
\includegraphics[width=\textwidth]{figures/diff-docsize-scale}
\caption{Different document sizes with modification-count scaled accordingly (11 MiB $\Leftrightarrow$ modifiy every 1000th node, 111 MiB $\Leftrightarrow$ modify every 11000 th node, 1111 MiB $\Leftrightarrow$ modify every 122221th node / Y-axis logarithmic scaled)} 
\label{fig:docScaling}
\end{figure}

\begin{table}[tb]
\centering 
\begin{tabular}[r]{|l|c|c|c|} 
\hline
& \textbf{11 MiB} & \textbf{111 MiB} & \textbf{1111 MiB}\\
\hline
\hline
\textbf{min} & 2957.79 & 33948.96 & 401878.64\\
\hline
\textbf{max} & 5694.65 & 44451.06 & 439337.71\\
\hline
\textbf{average} & 3323.96 & 36579.37 & 413158.13\\
\hline
\end{tabular}
\label{chap3:compDiffInstances}
\vspace{0.5em} 
\caption{Comparsion of different XMark instances (11 MiB, 111 MiB, 1111 MiB modifying every 1000st, 11000st and 122221st node). Runtime in ms.}
\end{table}

\begin{table}[tb]
\centering 
\begin{tabular}[r]{|l|c|c|c|} 
\hline
& \textbf{11 MiB} & \textbf{111 MiB} & \textbf{1111 MiB}\\
\hline
\hline
\textbf{min} & 1239.01 & 14208.30 & 197223.12\\
\hline
\textbf{max} & 3698.94 & 19135.01 & 271794.82\\
\hline
\textbf{average} & 1408.74 & 14596.86 & 210296.70\\
\hline
\end{tabular}
\label{chap3:compPrunedDiffInstances}
\vspace{0.5em} 
\caption{Comparsion of different XMark instances skipping subtrees of nodes with identical hash-values (11 MiB, 111 MiB, 1111 MiB modifying every 1000st, 11000st and 111000st node). Runtime in ms.}
\end{table}

\todo{plot the pruned diffs and mention the tables.

\subsection{Conclusion and Summary}
This chapter first introduced Treetank, the DBMS tailored to revisioned tree-structures. We motivated the import of differences between full dumps of temporal tree-structures to subsequently take full advantage of Treetanks' (1) revisioning strategies, (2) unique node-IDs which identify a node through all revisions and (3) hashes of each node, which almost guarantee a unique hash guarding the whole subtree through MD5 rolling hashes. The FMSE-algorithm has been implemented to support the initial import of differences in these full dumps, that is revisioned data (currently) in the form of XML-documents whereas each document represents one revision, a snapshot at a specific time. Considering no such data is available other even more sophisticated preprocessing steps have to be implemented and executed before a diff-algorithm on the revisioned data in Treetank can be used. Two of the use cases which are going to be discussed in Chapter \ref{sec::applications} require further preprocessing. Note that the FMSE-algorithm is used to import data which does not assume unique node-IDs and matches nodes based on a longest common subsequence (LCSS)-calculation (which is ambiguous) for leaf nodes and inner nodes in a bottom up traversal. Thus it might mismatch similar nodes eventuating in too many edit-operations. The algorithm is particularly useful to compare different tree-structures which have not temporally evolved.

Furthermore we have implemented many edit-operations which were not available in Treetank to support the implementation of the FMSE-algorithm and a very expressive agglomerated tree-structure. We have shown that a subsequent diff-calculation based on IDs and hashes which guard the whole subtree is faster than the same algorithm without utilizing hashes. However it depends on the properties of the tree-structures. If large subtrees can be skipped due to same hashes meaning they are unchanged the running time is reduced drastically.

Besides using hashes optionally to skip whole unchanged subtrees our ID-based diff-algorithm combines \texttt{INSERT/DELETE} and \texttt{DELETE/INSERT} sequences to a single replace-operation. To support an agglomerated tree-structure which incorporates nodes of both compared revisions described in the next chapter either emits diff-tuples of type \texttt{REPLACEDOLD} or \texttt{REPLACEDNEW} depending on which of the two subtrees are larger, thus increasing the expressiveness. Note that this detection potentially involves a lot of state if large subtrees are inserted/deleted or vice versa successively. Therefore we additionally provide a different replace-detection which uses heuristics checking right-sibling nodeKeys for equivalence or the parent node keys if in both revisions no right sibling exists).

Moves are optionally detected in a postprocessing-step by searching for \\\texttt{INSERT/DELETE} and \texttt{DELETE/INSERT} combinations with the same node-IDs. Move detection is especially useful to support analysts with an expressive visualization. Otherwise in document-centric XML, for instance DocBook\cite{docbook} documents, it might be impossible to draw conclusions from simple inserts/deletes, whereas an author simply moved a sentence along with other inserts/deletions of text and/or markup.
