\section{Treetank}\label{sec::treetank}

\subsection{Persistent storage enhancements}
While not exclusively developed for our tree-to-tree comparsion for completeness we want to meantion several techniques which have recently been developed to support the persistent storage of large tree-structures efficiently (with a minimum space overhead).

\begin{itemize}
\item Values of \texttt{TextNodes} are compressed by using the Deflate-algorithm which combines the LZ77 algorithm and Huffman coding. Decompressed values are cached in memory once they are requested. Furthermore only values which are greater than a certain length-threshold are compressed.
\item Pointers to neighbour nodes, the first child and the parent node are persisted as ranges.
\item As ranges are persisted node-IDs are efficiently compressed.
\item Whole \texttt{NodePage}s are compressed using the very fast Snappy-algorithms due to a lot of compression/ decompression in case of many modifications of the same NodePage in the BerkeleyDB log.
\item In case of the \texttt{DocumentNode} only the firstChild-pointer and descendant-count has to be persisted. Similar the serialization of \texttt{TextNode}s doesn't include the childCount and descendantCount as well as the firstChild-pointer.
\item The \texttt{NamePage} which is used to store String-names which are commonly repeated in XML-documents now contains index-mappings whereas we opted for different indexes based on an element-QName index, an attribute-QName index and a namespace/URI-index. This allows an XPath- or XQuery- Optimizer to use the index for queries as \texttt{count(//@attribute='foo')} or\\ \texttt{count(//element()='bar')}. We furthermore aim to provide backreferences to the nodes as we encountered far too long response-times on larger tree-structures. A path-like index therefore might be inevitable in the long term.
\item Deletion of \texttt{attribute}- and \texttt{namespace}-nodes in subtrees.
\end{itemize}

\subsection{ACID properties}
Consistency rules have been enhanced while developing our prototype. The following provides a brief overview about the ACID-properties of Treetank.

\begin{enumerate}
\item \emph{Atomicity} is ensured through the transaction layer and the interchangeable backend (currently BerkeleyDB). As such atomicity is even guaranteed in case of power failures, errors and crashes.
\item \emph{Consistency} as of now involves the checking of \texttt{QName}s for validity. At all times no adjacent text nodes are created which is consistent with the XPath/XQuery Data Model (XDM). We also introduced XML entity encoding for the XML characters serialization (in the \texttt{XMLSerializer} as well as the new \texttt{StAXSerializer} and \texttt{SAXSerializer}). Furthermore we check attribute \texttt{QName}s for duplicates and throw an appropriate runtime exception if a new attribute insertion would yield duplicates. Similarly insertion of duplicate namespace prefixes for namespaces of the same parent element-node are prohibited.
\item \emph{Isolation} is guaranteed through \emph{Snapshot-Isolation} which is based on the transaction-, page- and I/O-layer through versioning. Furthermore currently only one write transaction is allowed per resource. To maximize the properties of tree-structures the implementation of concurrent write-transactions on different subtrees with appropriate locking is in development.
\item \emph{Durability} is guaranteed through the backend. The transaction log created by Treetank's BerkeleyDB-binding implemented as a cache to store all changed pages and nodes is written and flushed on transaction commit.
\end{enumerate}

\subsection{Axis}
The axis in Treetank have been changed to adhere to the \texttt{hasNext()} and \texttt{next()} specifications of the \texttt{Iterable} interface. The check if \texttt{getNext()} is true is added to all axis such that \texttt{hasNext()} is idempotent. It simply checks a flag which is set in \texttt{resetToLastKey()} to make sure the transaction points to the node after the last call to \texttt{hasNext()} without changing the node-ID to which to move in the next call to \texttt{next()}. Furthermore the transaction now is not moved forward in \texttt{hasNext()} anymore which is done only when calling \texttt{next()}. Instead a variable denoting the next node-ID is set which is used by the \texttt{next()} implementation to move to the next node. Furthermore \texttt{next()} now also is idempotent, simply checking if it has been called before. When true and \texttt{hasNext()} has not been called immediately before it is first called by \texttt{next()}.


