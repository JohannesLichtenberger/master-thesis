\section{Summary, Conclusion and Future Research}\label{sec::conclusion}
\subsection{Summary}
A full pipeline has been implemented backed by the secure tree-storage system Treetank ranging from (extensive) preprocessing to ID-less and ID-based diff-algorithms to new layout algorithms developed for comparing tree-structures.

Almost all data is subject to preprocessing. Wikipedia is used to demonstrate the feasability of our approach for comparing the temporal evolution of several articles by their inherent tree-structure. The Wikimedia Foundation provides only full Wikipedia dumps which are not sorted by revision-timestamps. Therefore it must be sorted at first using Hadoop. Importing structural changes which should be revealed by the visualizations afterwards requires a diff-algorithm which does not require unique node IDs. Thus the FMSE-algorithm described in Chapter \ref{sec::relwork} is implemented (Chapter \ref{sec::differences}) as well as several missing edit-operations in Treetank (\texttt{copy}, \texttt{move}, \texttt{replace}), whereas others have been extended to adhere to the XPath/XQuery Data Model (XDM) to simplify the internal ID-based diff-algorithm and to add to the visualizations' expressiveness\footnote{for instance no two adjacent text-nodes are ever created}. The FMSE-algorithm is furthermore useful to compare multiple similar trees. In both cases either the evolution of a tree or different trees are imported as snapshots/revisions in a single Treetank resource. In the latter case changes between a base tree and several other trees are imported. Leveraging the ID-based diff-algorithm the small multiple differential variant visualizes the comparison between two revisions/trees in currently four regions of the screen (top left, top right, bottom right, bottom left). Other studied applications include the comparison of snapshots of a directory in a filesystem and two revisions of XML-exported LFG-grammars.

An ID-based diff-algorithm has been developed to compare imported data based on snapshots/revisions, whereas the comparison is \emph{not} restricted to both subsequent revisions and whole documents. A fast version utilizes hash-values of each node generated during the import. These are derived from the nodes' descendants and used to reduce the runtime of the algorithm. The whole subtree of nodes with identical hash-values is skipped.

All visualizations capable of visualizing an aggregated tree-structure trigger the ID-based diff-algorithm if needed. A \emph{SunburstView} visualizing the aggregated tree-structure build through collecting diff-tuples observed from the ID-based diff-algorithm is one of our major contributions. Furthermore, drawing a new Sunburst-layout for a selected-node to drill down into the tree does not require the invocation of the diff-algorithm. A notable exception is the itemsize-based pruning because the diffs are usually not saved to avoid their constant in-memory space consumption. Instead they are usually subject to garbage collection. The type of diff however is saved as part of the created Sunburst item and used by the visualization through color coding. A new Sunburst layout algorithm has been designed to specifically support the analysis of structural changes, which are featured prominently between two rings whereas the ring which is closer to the root node denotes the maximum depth of unchanged nodes (thus denotes the border of unchanged nodes) and the second denotes the maximum depth of changed nodes. Thus the area between the two rings encloses all changed nodes as well as unchanged nodes in the subtree of updated nodes. The first changed node in a subtree is dislocated from its original place (the depth is increased appropriately) to reside between the two rings supporting a tree-ring metapher based on the analogy of an aging tree in the nature which adds growth rings every year.

The \emph{SunburstView} in comparison mode furthermore incorporates three pruning techniques. First, an itemsize based approach to filter nodes based on their extend is provided. It is used to speed up the creation of the Sunburst items, but does not affect the runtime of the diff-algorithm used in the first place. Second, a method utilizing the hash-based diff-option skips whole subtrees of unchanged nodes with identical hash-values and thus builds solely interesting items to the task at hand (which is analysing structural and non-structural changes). A third variant even skips the creation of building items for nodes with unchanged content and identical hash-values altogether. This variant is especially interesting for very large tree-structures to minimize memory consumption and to provide maximum space for subtrees which contain changed nodes.

Besides, sometimes it is interesting to view the whole aggregated tree in an overview. To emphasize structural changes in addition to our semantic zoom the arc of an item is based on the \texttt{subtree-size} of a node as well as of the number of modifications in its subtree, whereas the amount which one affects the arc at most is chosable by a slider. Note that the number of modifications is multiplied to a constant factor as modifications are usually small compared to the whole tree. Furthermore the \texttt{subtree-size} must be added as a fallback which is needed to cover the case of zero modifications in the subtree.

In addition to the new Sunburst layout supporting comparisons several small multiple display variants, based on the \emph{SunburstView} have been developed to support the comparison of currently at most five revisions. An incremental version displays changes related to a sliding window of two subsequent revisions. The left upper view shows a comparison between the loaded baseRevision and $baseRevision + 1$, the right upper view displays the comparision between $baseRevision + 1$ and $baseRevision + 2$ whereas the comparsion between two subsequent revisions is done clockwise until either no more revisions are available or five revisions have been compared (all four squarified regions are filled with Sunburst views). A differential version compares subsequent revisions to the loaded baseRevision. This version is ideal to compare different tree-structures to a reference tree. A hybrid view first compares the baseRevision with the newest revision which can be drawn in the bottom left square of the visualization. Subsequently it computes differences just like in the incremental version but blackens changes which occur in subsequent incremental comparisons. The color denoting the type of change of a node gradually lightens.

\subsection{Conclusion}
We presented several visualizations and diffing algorithms tailored to comparing tree-structures. In retrospective the goals described in the introduction have been achieved. The GUI-frontend embedding the visualizations aids analysts in comparing tree-structures ranging from temporal to generic similar trees. Its main strength is the comparison of structural changes, whereas a smilarity-measure for \texttt{element}-nodes depends on the amount of overlapping nodes in its subtree. In contrast \texttt{text}-nodes are compared based on the Levenshtein-algorithm as \texttt{text}-nodes are always leaf-nodes in a tree. Other algorithms might be easily included for instance to compare numerical values.

Our approach based on a tight storage integration integrates several edit-operations utilizing an expressive aggregated tree-structure build through observing diffs from the ID-based diff algorithm. The ID-based algorithm supports two modes. Either only structural nodes which denote the structure of a tree (currently the subset of XML nodes \texttt{DocumentNode}, \texttt{ElementNode} and \texttt{TextNode}s) are compared or structural and non structural nodes (adding \texttt{NamespaceNode}s and \texttt{AttributeNode}s). The encountered diffs are used to build an aggregated tree-structure which is processed to construct a novel Sunburst layout tailored to tree-comparisons. In contrast to other visual tree-comparison tools our prototype incorporates several edit-operations including moved and replaced nodes which are rarely seen in other visualizations. Filtering-mechanisms facilitate the comparison of very large tree-structures. Note that besides CodeFlows\cite{} and Treevolution\cite{theron2006hierarchical} no other approach described in Chapter \ref{sec::relwork} to the best of our knowledge incorporates such filters and therefore most likely is not useful to inspect large datasets. Two filtering mechanisms depend on hashes which are used to compare the whole subtree of a node including itself. Subtrees are skipped from comparison if the hashes are identical. Thus they are neither traversed nor items are build subsequently. Besides building an aggregated tree-structure from observing changes by the ID-based diff-algorithm no state is involved. Unlike the straight forward approach of building two in memory datastructures with nodes of both revisions which are going to be compared our algorithm uses less space and is much faster. 

In addition to a novel Sunburst layout we implemented three different \emph{SmallMultiplesView} variants. Two of them, the incremental- and the differential-view compute the diffs and the subsequent visualizations in each of the four screen regions (top-left, top-right, bottom-right, bottom-left assuming five subsequent revisions of the tree-structure to compare exist) in parallel. On mouse-over items are highlighted in each region in which they are present. Compared to an icicle-view which connects unchanged items in each revision by splines our approach features changes much more prominently through the semantic zoom/the tree-ring metapher as well as a modifyable modification-rate. A hybrid variant currently suffers from a lack of visually distinguishable colors encoding the type of change of a node. Furthermore nodes added and removed during the comparison of multiple revisions are not visible as the Sunburst items which are visible during each comparison are build through comparing the first and the last revision which are compared. However, to make the view expressive adding diff-tuples during subsequent comparisons of all revisions to an agglomeration is necessary. A first implementation however was way too slow.

\subsection{Future Research}
Many topics are subject to further research. 

\begin{itemize}
\item First of all we want to incorporate already developed temporal XPath axis in an XQuery processor, most probably Brackit\cite{Brackit}, which is important to further analyse temporal evolving tree-structures. Furthermore in order to support fast query-response times it is inevitable to provide indexes. 
\item Extend the Hierarchical Edge Bundles to use a gradient color to indicate the direction of moves instead of arrows.
\item Building an index structure for visualizations of consecutive revisions (the small multiple incremental-variant and the SunburstView comparing consecutive revisions).
\item Evaluation and integration/implementation of various other tree-similarity measures.
\item Support query-selection of interesting subtrees before invoking the ID-based diff-algorithm.
\end{itemize} 
