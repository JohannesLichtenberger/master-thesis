\section{Summary, Conclusion and Future Research}\label{sec::conclusion}
\subsection{Summary}
A full pipeline has been implemented backed by the secure tree-storage system Treetank ranging from (extensive) preprocessing to ID-less and ID-based diff-algorithms to new layout algorithms developed for comparing tree-structures.

Almost all data is subject to preprocessing. Wikipedia is used to demonstrate the feasability of our approach for comparing the temporal evolution of several articles by their inherent tree-structure. The Wikimedia Foundation provides only full Wikipedia dumps which are not sorted by revision-timestamps. Therefore it must be sorted at first using Hadoop. Importing structural changes which should be revealed by the visualizations afterwards requires a diff-algorithm which does not require unique node IDs. Thus the FMSE-algorithm described in Chapter \ref{sec::relwork} is implemented (Chapter \ref{sec::differences}) as well as several missing edit-operations in Treetank (\texttt{copy}, \texttt{move}, \texttt{replace}), whereas others have been extended to adhere to the XPath/XQuery Data Model (XDM) to simplify the internal ID-based diff-algorithm and to add to the visualizations' expressiveness\footnote{for instance no two adjacent text-nodes are ever created}. The FMSE-algorithm is furthermore useful to compare multiple similar trees. In both cases either the evolution of a tree or different trees are imported as snapshots/revisions in a single Treetank resource. In the latter case changes between a base tree and several other trees are imported. Leveraging the ID-based diff-algorithm the small multiple differential variant visualizes the comparison between two revisions/trees in currently four regions of the screen (top left, top right, bottom right, bottom left). Other studied applications include the comparison of snapshots of a directory in a filesystem and two revisions of XML-exported LFG-grammars.

An ID-based diff-algorithm has been developed to compare imported data based on snapshots/revisions, whereas the comparison is \emph{not} restricted to both subsequent revisions and whole documents. A fast version utilizes hash-values of each node generated during the import. These are derived from the nodes' descendants and used to reduce the runtime of the algorithm. The whole subtree of nodes with identical hash-values is skipped.

All visualizations capable of visualizing an aggregated tree-structure trigger the ID-based diff-algorithm if needed. A \emph{SunburstView} visualizing the aggregated tree-structure which is build through collecting diff-tuples observed from the ID-based diff-algorithm is one of our major contributions. Furthermore, drawing a new Sunburst-layout for a selected-node to drill down into the tree does not require the invocation of the diff-algorithm. A notable exception is the itemsize-based pruning since the diff-tuples are usually not saved to avoid their constant in-memory space consumption. Instead they are subject to garbage collection. The type of diff however is saved in the created Sunburst item and used by the visualization through color coding. A new Sunburst layout algorithm has been designed to specifically support the analysis of structural changes, which are featured prominently between two rings whereas the ring which is closer to the root node denotes the maximum depth of unchanged nodes (thus denotes the border of unchanged nodes) and the second ring denotes the maximum depth of changed nodes. Thus the area between the two rings encloses all changed nodes (as well as unchanged nodes in the subtree of updated nodes). The first changed node in a subtree is dislocated from its original place to reside between the two rings supporting a tree-ring metapher based on the analogy of an aging tree in the nature which adds growth rings every year.

The \emph{SunburstView} in comparison mode furthermore incorporates three pruning techniques. First, an itemsize based approach to filter nodes based on their extend is provided. It is used to speed up the creation of the Sunburst items, but does not affect the runtime of the diff-algorithm used in the first place. Second, a method utilizing the hash-based diff-option skips whole subtrees of unchanged nodes with identical hash-values and thus builds solely interesting items to the task at hand (which is analysing structural and non-structural changes). A third variant even skips the creation of building items for nodes with unchanged content and identical hash-values altogether. This variant is especially interesting for very large tree-structures to minimize memory consumption and to provide maximum space for subtrees which contain changed nodes.

Besides, sometimes it is interesting to view the whole aggregated tree in an overview. To emphasize structural changes in addition to our semantic zoom the arc of an item is based on the \texttt{subtree-size} of a node as well as of the number of modifications in its subtree, whereas the amount which one affects the arc at most is chosable by a slider. Note that the number of modifications is multiplied to a constant factor as modifications are usually small compared to the whole tree. Furthermore the \texttt{subtree-size} must be added as a fallback which is needed to cover the case of zero modifications in the subtree.

In addition to a novel Sunburst layout we provide three different small multiple display variants. Two of them, the incremental- and the differential-view compute the diffs and the subsequent visualizations in each of the four screen regions (top-left, top-right, bottom-right, bottom-left assuming five subsequent revisions of the tree-structure to compare exist) in parallel. The incremental version displays changes related to a sliding window of two subsequent revisions. The differential version displays changes related to the opened base revision, that is either a reference tree if multiple similar trees are compared or  On mouse-over items are highlighted in each region in which they are present. Compared to an icicle-view which connects unchanged items in each revision by splines our approach features changes much more prominently through the semantic zoom/the tree-ring metapher as well as a modifyable modification-rate. A hybrid variant currently suffers from a lack of visually distinguishable colors encoding the type of change of a node. Furthermore nodes added and removed during the comparison of multiple revisions are not visible as the Sunburst items which are visible during each comparison are build through comparing the first and the last revision which are compared. However to provide an expressive view adding diff-tuples during subsequent comparisons of all revisions to an agglomeration is necessary. Yet, a first implementation proved to be too slow in informal tests.

%In addition to the new Sunburst layout supporting comparisons several small multiple display variants, based on the \emph{SunburstView} have been developed to support the comparison of currently at most five revisions. An incremental version displays changes related to a sliding window of two subsequent revisions. The left upper view shows a comparison between the loaded baseRevision and $baseRevision + 1$, the right upper view displays the comparision between $baseRevision + 1$ and $baseRevision + 2$ whereas the comparsion between two subsequent revisions is done clockwise until either no more revisions are available or five revisions have been compared (all four squarified regions are filled with Sunburst views). A differential version compares subsequent revisions to the loaded baseRevision. This version is ideal to compare different tree-structures to a reference tree. A hybrid view first compares the baseRevision with the newest revision which can be drawn in the bottom left square of the visualization. Subsequently it computes differences just like in the incremental version but blackens changes which occur in subsequent incremental comparisons. The color denoting the type of change of a node gradually lightens.

\subsection{Conclusion}
We presented several visualizations and diffing algorithms tailored to comparing tree-structures. In retrospective the goals described in the introduction have been achieved. The GUI-frontend embedding the visualizations aids analysts in comparing tree-structures ranging from temporal to generic similar trees. Its main strength is the comparison of structural changes, whereas a smilarity-measure for \texttt{element}-nodes depends on the amount of overlapping nodes in its subtree. In contrast \texttt{text}-nodes are compared based on the Levenshtein-algorithm as \texttt{text}-nodes are always leaf-nodes in a tree. Other algorithms might be easily included for instance to compare numerical values.

Our approach based on a tight storage integration integrates several edit-operations utilizing an expressive aggregated tree-structure build through observing diffs from the ID-based diff algorithm. The ID-based algorithm supports two modes. Either only structural nodes which denote the structure of a tree (currently the subset of XML nodes \texttt{DocumentNode}, \texttt{ElementNode} and \texttt{TextNode}s) are compared or structural and non structural nodes (adding \texttt{NamespaceNode}s and \texttt{AttributeNode}s). The encountered diffs are used to build an aggregated tree-structure which is processed to construct a novel Sunburst layout tailored to tree-comparisons. In contrast to other visual tree-comparison tools our prototype incorporates several edit-operations including moved and replaced nodes which are rarely seen in other visualizations. Filtering-mechanisms facilitate the comparison of very large tree-structures. Note that besides CodeFlows\cite{} and Treevolution\cite{theron2006hierarchical} no other approach described in Chapter \ref{sec::relwork} to the best of our knowledge incorporates such filters and therefore most likely is not useful to inspect large datasets. Two filtering mechanisms depend on hashes which are used to compare the whole subtree of a node including itself. Subtrees are skipped from comparison if the hashes are identical. Thus they are neither traversed nor items are build subsequently. Besides building an aggregated tree-structure from observing changes by the ID-based diff-algorithm no state is involved. Unlike the straight forward approach of building two in memory datastructures with nodes of both revisions which are going to be compared our algorithm uses less space and is much faster. 

The presented approach facilitates the comparison of tree-structures through various linked visualizations depicting the tree-structures at various levels of detail. Small multiple displays provide a high level view of the differences between multiple tree-structures. Linking and brushing is used to highlight nodes. The \emph{SunburstView} incorporates both a mode to visualize one tree-structure and a mode to visualize comparisons between two tree-structures. A new layout-algorithm facilitates comparing tree-structures through highlighting changes in a prominent place with a global distortion. Furthermore different filtering methods allow the comparison of large trees. Details are shown on demand through a mouseover effect and a linked \texttt{TextView}. A selection of a new root-node togehter with a simple undo-operation allows to drill down into the tree as known from other Sunburst-visualizations. However costly recalculation of diff-tuples, modifications and subtree-sizes of each node is omitted in all cases but the itemsize-based pruning. Instead we recalculate the maximum depth of unchanged nodes and scale a new list of items to fit the new boundaries. The \texttt{TextView} provides a serialization of (sub)trees linked with the \texttt{SunburstView} also tailored to large tree-structures.

Unlike state-of-the-art visualizations of tree comparisons described in Chapter \ref{sec::relwork} our approach is entirely database driven. The DBMS is tailored to temporal tree-structures which are stored as snapshots. Each node in the database/resource is unique and remains stable throughout all revisions. As most trees do not inhibit unique node-IDs we implemented an ID-less diff-algorithm called FMSE based on inner-node/leaf-node similarity measures to import differences, which eventuates in a new revision. Afterwards we are able to use a fast diff-algorithm ($O(n+m)$) based on the generated node-IDs and furthermore are able to utilize hashes to further speed up the algorithm. Due to FMSE our similarity-measure between trees is based on a matching algorithm which computes the longest common subsequence (LCS) bottom up and furthermore tries to find cross-matches of unmatched nodes.

The next section evaluates our approach similar to Chapter \ref{sec::relwork} according to several attributes.

\subsubsection{Evaluation Criteria}

\begin{itemize}
\item \emph{SpaceFilling} Space filling techniques try to maximize the usage of available screen space and thus facilitate a higher information density. Sunburst layouts are generally space filling, but in contrast to Treemaps lack space filling properties in the corners. However in our case the corners are used to display GUI components and legends. The small multiple variants currently have too much unused space which is due to the often times non squarified screen viewport depending on the extends of the main window. As we just scale each visualization of the comparison of each two revisions the small multiple variants currently include too much unused space due to often times non squarified screen viewport which depends (1) on the size of the main window and (2) how many visualizations are currently enabled. Thus, in a future version we will use a squarified clip of the view depending on the maximum depth to generate minimized offscreen buffers for the four regions. Other space filling approaches include Icicle plots (Code Flows) which are comparable in space consumption as always the two complete tree-structures to compare are plottet. In our case unchanged nodes are not plotted twice. Furthermore a special stable Spiral-Treemap layout has been proposed which utilizes all available screen space and remains relatively stable after changes. Usual Treemap layouts suffer from abrupt layout changes during modifications of the underlying data.
\item \emph{Hierarchy} The Hierarchy in Sunburst layouts is very well depicted due to the adjacency based layout whereas it is not as obvious in Treemaps which encapsulate child items. Cushion Treemaps have been developed for better readability of hierarchical relationships using shading. However they are still not as good readable as in adjacency based layouts. Code flows utilizes Icicle plots which are rectangular views of the radial Sunburst layout, thus adjacency based and very well readable. Our approach optionally plots a node-link diagram on top of the Sunburst layout to further illustrate the relationships such that the hierarchy is at least as well depicted as in other node-link diagrams (for instance in TreeJuxtaposer and Treevolution). 
\item \emph{Readability} To both use a node-link diagram and at the same time a Sunburst layout facilitates a higher information density as individual nodes are color-coded based on their type of difference. Furthermore their child/parent relationship, the links between the nodes are displayed through the node-link diagram overlay. Thus we are able to map attributes to the arc/extension of the Sunburst items, the color of the arcs and the color of the dots/nodes in the node-link diagram. To maximize the information density theoretically it is possible to use histograms in the Sunburst items instead of just using one color for the whole item to visualize multiple attributes instead of one. However we are confident that the items usually are too small, such that a whole histogram will certainly not be readable. To support better readability of item-labels our visualization is able to be rotated. However, node labels of Treemaps and Icicle plots usually are better readable due to their rectangular display in comparison to circular plotted labels. Thus we decided to extend our \emph{TextView} to take the agglomerated tree-structure into account. It is an ideal partner of the \emph{SunburstView} as it provides better readability of small subtrees but lacks an overview about the entire tree-structure and all differences provided by the \emph{SunburstView}. Furthermore moves can not be visualized.
\item \emph{Similarity of ID-less tree-structures} Some proposed tree-to-tree comparsion visualizations depend on node-IDs (Spiral-/Contrast-Treemap\cite{tu2007visualizing}) or the comparison technique has not been meantioned. Others depend on domain characteristics (Treejuxtaposer\cite{munzner2003treejuxtaposer}, Code Flows\cite{telea2008code}). Juxtaposer seems to rely on unique leaf node labels. Otherwise it is not obvious how to map node labels to their postorder rank on a region plane. In contrast to Treejuxtaposer and other proposed systems our prototype is able to compare every kind of tree-structure.
\item \emph{Structural changes} Our visualizations, in particular the \emph{SunburstView} and the small multiple display variants support the highlighting of all kind of structural-changes (inserts, deletes, updates, replace and move-operations) through color-coded nodes. In case of moves- links, currently depicted as arrows, denote the movement from their original- to their target-place using hierarchical edge bundling to avoid or at least reduce visual clutter due to overlapping lines or curves. Furthermore the extend of the sunburst items is based on the nodes' subtree size \emph{and} the number of modifications in the subtree. Most other visualizations do provide a global distortion to further emphasize changes except Treejuxtaposer to the best of our knowledge.
\item \emph{Non structural changes} are attribute-value changes of nodes. Changes in \texttt{TextNode}s are color coded to denote that the value is \texttt{UPDATED} through coloring the node in the overlapping node-link diagram accordingly. Furthermore the color of the Sunburst item reflects their similarity using the Levenshtein distance.
\item \emph{Filtering} is one of our primariy concerns. The focus of this thesis evolved around the idea of comparing Treetank-resources by interactive visualizations. As Treetank is a secure storage system it naturally often times stores very large tree-structures. Thus, our first consideration was to prune items which cannot be visually perceived, that is Sunburst items which are too small are not created. However this only affects the creation of Sunburst items and does not improve the ID-based diff-algorithm. To speed up both, the ID-based diff algorithm as well as the construction of Sunburst items we developed a diff-algorithm variant which skips subtrees of nodes with identical hash-values and thus moves both transactions to the next node in the XPath \texttt{following::}-axis. Accordingly, in case large subtrees are skippable the diff-algorithm using hash-comparisons is much faster. Besides even less items usually have to be created and in case of a subtree-selection only the itemsizes have to be recalculated instead of reinvoking the diff-algorithm, recalculate the descendant- and modification-count for each node, and the preorder traversal of the agglomerated tree-structure with all stack-adjustements is unnecessary. Pushing the idea of filtering by hashvalues to its limits involves to avoid the creation of items for the nodes with identical hash-values. These filtering techniques furthermore enlarge changed subtrees naturally as the arc of the items is based on the \emph{subtree-size} of each node and the number of \emph{modifications} therein. TreeJuxtaposer once more along with Code Flows to the best of our knowledge seems to be the only system which is able to handle large tree-structures but the diff-algorithm of TreeJuxtaposer relies on unique node labels. Code Flows does not provide a global filtering method such that their filtering is comparable with our method to drill down into the tree. However, due to filtering by queries the filtering is mightier. Implementing such a behavior in our prototype will be straight forward allowing the user to specify an XPath-query and invoke the diff-algorithm for each result on both revisions. Our current approach is able to filter differences and related context nodes on a global basis and on subtrees once a user drilled down into the Sunburst visualization with a guaranteed visibility of modifications much like in TreeJuxtaposer.
\end{itemize}

Table \ref{chap5:comparsion} summarizes the visualizations according to the evaluation criterias specified.

\begin{table}[tb]
\centering 
\begin{tabular}[r]{|l|c|c|c|c|c|c|} 
\hline
\centering\textbf{visualization approaches} & \begin{sideways}\textbf{space filling}\end{sideways} & \begin{sideways}\textbf{hierarchy}\end{sideways} & \begin{sideways}\textbf{labels}\end{sideways} & \begin{sideways}\textbf{structural changes}\end{sideways} & \begin{sideways}\textbf{non structural changes\ }\end{sideways} & \begin{sideways}\textbf{filtering}\end{sideways}\\
\hline
\hline
\textbf{Sunburst} & o & + & +\footnotemark & + & + & +\\
\hline
\textbf{Spiral-/Contrast-Treemap} & + & o & + & o & + & -\\
\hline
\textbf{Treevolution} & - & o & o\footnotemark & o & - & -\\
\hline
\textbf{Code Flows} & + & + & + & o & - & +\\
\hline
\textbf{Juxtaposer} & - & + & o & + & - & o \\
\hline
\textbf{Ripple Presentation} & - & + & o & + & - & -\\
\hline
\textbf{IVCoMT} & +\footnote{the matrix view} & + & + & + & o & -\\
\hline
\end{tabular}
\label{chap5:comparsion}
\vspace{0.5em} 
\caption{Comparsion of tree-to-tree comparison visualizations. Appendix \ref{sec::tablelegend} provides a detailed legend.}
\end{table}

Most proposed visualizations rely on stable unique IDs (the Contrast\\Treemap\cite{tu2007visualizing}, Code Flows\cite{telea2008code}, TreeJuxtaposer\cite{munzner2003treejuxtaposer} (unique node labels)) and do not include the detection of \texttt{replace}- and \texttt{move}-operations. However Code Flows visualizes moves due to spline connections between matching nodes with the same ID in two adjacent icicle plots. Due to the reliability on unique node IDs these visualizations do not cover trees which do not include unique node-IDs or labels. In contrast our prototype is able to determine and visualize these tree-structures utilizing the FMSE-algorithm to import differences through similarity metrics for leaf- and inner-nodes and a bottom-up LCS computation.

\footnotetext{the labels are better readable in Treemaps and Icicle plots due to their rectangular nature instead of drawing the label on an arc}
\footnotetext{rotating however might prevent some labels from overplotting}

Interactive Visual Comparison of Multiple Trees(IVCoMT\cite{bremm2011interactive}) provides the ability to compare multiple trees through various linked views allowing the comparison on different levels. However we assume that the similarity metrics are defined for phylogenetic trees which have unique labels and that the visualizations are tailored to many small trees in comparison to a few very large tree-structures or a temporal evolving tree as in our case.

\subsection{Future Research}
Many topics are subject to further research. 

\begin{itemize}
\item First of all we want to incorporate already developed temporal XPath axis in an XQuery processor, most probably Brackit\cite{Brackit}, which is important to further analyse temporal evolving tree-structures. Furthermore in order to support fast query-response times it is inevitable to provide indexes. 
\item A recently developed path summary is usable to significantly speed up the comparison of very large tree-structures if isomorphism is not an issue, for instance by providing a high level matrix overview about the changes. 
\item Extend the Hierarchical Edge Bundles to use a gradient color to indicate the direction of moves instead of arrows.
\item Building an index structure for visualizations of consecutive revisions (the small multiple incremental-variant and the SunburstView comparing consecutive revisions).
\item Evaluation and integration/implementation of various other tree-similarity measures.
\end{itemize} 
