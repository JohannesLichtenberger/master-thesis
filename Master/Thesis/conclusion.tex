\section{Summary, Conclusion and Future Research}\label{sec::conclusion}
\subsection{Summary}
A full pipeline has been implemented backed by the secure tree-storage system Treetank ranging from (extensive) preprocessing to ID-less and ID-based diff-algorithms to new layout algorithms developed for 

Almost all data is subject to preprocessing. In the case of Wikipedia we aimed at comparing the temporal evolution of several articles. The Wikimedia Foundation provides only full Wikipedia dumps which aren't sorted by revision-timestamps. Therefore it had to be sorted at first using Hadoop. Importing structural changes which should be revealed by the visualizations afterwards requires a diff-algorithm which doesn't operate on unique node IDs. Thus the FMSE-algorithm described in Chapter \ref{sec::relwork} and \ref{sec::differences} has been implemented as well as several missing edit-operations in Treetank (\texttt{copy}, \texttt{move}, \texttt{replace}), whereas others have been extended to adhere to the XPath/XQuery Data Model (XDM) to simplify the internal ID-based diff-algorithm and to add to the visualizations' expressiveness (no two adjacent text-nodes are ever created). The FMSE-algorithm is furthermore useful to compare generic trees. In this case structural changes between a base tree and several other trees are imported consecutively which are visualized by the SmallMultiples differential view in a subsequent step. Other studied applications include the comparison of snapshots of a directory in a filesystem and two revisions of XML-exported LFG-grammars.

An ID-based diff-algorithm has been developed to compare imported data based on snapshots/revisions, whereas the comparison is \emph{not} restricted to both subsequent revisions and whole documents. A fast version utilizes hash-values of each node generated during the import. These are derived from the nodes' descendants and used to reduce the run-time of the algorithm. The algorithm can skip the comparison of the whole subtree of every node with a matching hash-value.

The visualizations trigger the ID-based diff-algorithm if needed. A \emph{SunburstView} based on aggregated tree-structures is one of the major contributions. Drawing a new Sunburst-layout for a selected-node to drill down into the tree doesn't require the invocation of the diff-algorithm. A notable exception is the itemsize-based pruning because the diffs are usually not saved to avoid their constant in-memory space consumption. Instead they are usually subject to garbage collection. The type of diff however is saved as part of the created Sunburst item and used by the visualization. 

A new Sunburst layout algorithm has been designed to specifically support the analysis of structural changes, which are featured prominently between two rings whereas the first inner ring denotes the maximum depth of unchanged nodes and the second denotes the maximum depth of changed nodes. The first changed node in a subtree is semantically zoomed from its original place (the depth is increased) to reside between the two rings supporting a tree-ring metapher based on the analogy of an aging tree in the nature which adds growth rings every year.

The variant of the \emph{SunburstView} which has been designed to compare tree-structures furthermore incorporates three filtering methods. First, an itemsize based approach to filter nodes based on their extend is provided. It is used to speed up the creation of the Sunburst items, but does not effect the run-time of the diff-algorithm used in the first place. Second, a method utilizing the hash-based diff-variant skips whole subtrees of unchanged nodes and thus builds solely interesting items to the task at hand (which is analysing structural changes). A third variant even skips the creation of building items for nodes with unchanged content altogether. This variant is especially interesting for very large tree-structures to keep the memory consumption to a minimum and to provide maximum space for subtrees which contain changed nodes.

Besides filtering uninteresting nodes automatically reducing the run-time of the diff-algorithm and/or the creation of Sunburst items and reducing in-memory space consumption sometimes it is interesting to view the whole aggregated tree in an overview. To still emphasize structural changes the extend of an item is based on the \texttt{descendant-or-self} count of a node as well as of its modification count, whereas the amount which one affects the extend at most can be chosen by a slider. Note that the modification-count is based on the number of modification in the nodes' subtree as well as on a constant factor the which is multiplied as modifications are usually small compared to the whole tree plus the addition of the \texttt{descendant-or-self} count as a fallback which needed in case of zero modifications in the subtree. The addition is needed in case of the slider to adjust how much the modifications contribute to the extension is set to zero, such that the extend is solely based on the \texttt{descendant-or-self} count.

In addition to the enhanced \texttt{SunburstView} supporting comparisons several \emph{SmallMultipleView} variants, based on the \emph{SunburstView} have been developed to support an overview about the changes ranging up to the comparsion of currently at most five revisions. An incremental version displays changes related to a sliding window of two subsequent revisions. The left upper view shows a comparison between the loaded baseRevision and $baseRevision + 1$, the right upper view displays the comparision between $baseRevision + 1$ and $baseRevision + 2$ whereas the comparsion between two subsequent revisions is done clockwise until either no more revisions are available or five revisions have been compared (all four squarified regions are filled with Sunburst views). A differential version compares subsequent revisions to the loaded baseRevision. This version is ideal to compare different tree-structures to a reference tree. A hybrid view first compares the baseRevision with the last revision which can be drawn in the bottom left square of the visualization. Subsequently it computes differences just like in the incremental version but blackens changes which occur in subsequent incremental comparisons.

\subsection{Conclusion}
In retrospective the goals described in the introduction have been achieved. The GUI-frontend embedding the visualizations aids analysts in comparing tree-structures ranging from temporal to generic similar trees. Its main strength is the comparison of structural changes, whereas a smilarity-measure for \texttt{element}-nodes depends on the amount of overlapping nodes in its subtree. In contrast \texttt{text}-nodes are compared based on the Levenshtein-algorithm as \texttt{text}-nodes are always leaf-nodes in a tree. Other algorithms might be easily included for instance to compare numerical values.

Our approach based on a tight storage integration integrates several edit-operations utilizing an expressive aggregated tree-structure build through observing diffs from the ID-based diff algorithm. The ID-based algorithm supports two modes. Either only structural nodes (\texttt{DocumentNode}, \texttt{ElementNode} and \texttt{TextNode}s) are compared or structural and non structural nodes (adding \texttt{NamespaceNode}s and \texttt{AttributeNode}s). The encountered diffs are saved in an associative array and further processed to construct a novel Sunburst layout tailored to tree-comparisons. In contrast to other visual tree-comparison tools our prototype incorporates several edit-operations including moved and replaced nodes which are rarely seen in other visualizations. Filtering-mechanisms facilitate the comparison of very large tree-structures. Note that no other approach described in Chapter \ref{sec::relwork} to the best of our knowledge incorporates such filters and therefore most likely is not useful to inspect large datasets. Two filtering mechanisms depend on hashes which are used to compare the whole subtree of a node including itself. Subtrees are skipped from comparison if the hashes are identical. Thus they are neither traversed nor items are build subsequently. Besides building an aggregated tree-structure from observing changes by the ID-based diff-algorithm no state is involved. Unlike the straight forward approach of building two in memory datastructures with nodes of both revisions which are going to be compared our algorithm uses less space and is much faster. Furthermore a new Guava based cache preloads node pages in a dedicated thread and thus facilitates faster traversal of large tree-structures.

In addition to a novel Sunburst layout we implemented three different \emph{SmallMultiplesView} variants. Two of them, the incremental- and the differential-view compute the diffs and the subsequent visualizations in each of the four screen regions (top-left, top-right, bottom-right, bottom-left assuming five subsequent revisions of the tree-structure to compare exist) in parallel. On mouse-over items are highlighted in each region in which they are present. Compared to an icicle-view which connects unchanged items in each revision by splines our approach features changes much more prominently through the semantic zoom/the tree-ring metapher as well as a modifyable modification-rate. A hybrid variant currently suffers from the lack of visual 

\subsection{Future Research}
Many topics are subject to further research. 

\begin{itemize}
\item First of all we want to incorporate the already developed temporal XPath axis in an XQuery processor, most probably Brackit\cite{Brackit}, which is especially important to further analyse temporal evolving tree-structures. Therefore it furthermore will be inevitable to provide indexes for fast response-times of the visualizations. 
\item Extend the Hierarchical Edge Bundles to use a gradient color to indicate the direction of moves instead of arrows.
\item Building an index structure for visualizations of consecutive revisions (the SmallMultiple incremental-variant and the SunburstView comparing consecutive revisions).
\item Evaluation and integration/implementation of various other tree-similarity measures.
\item Support queries to select interesting regions before invoking the ID-based diff-algorithm.
\end{itemize} 
