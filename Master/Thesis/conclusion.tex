\section{Summary, Conclusion and Future Research}\label{sec::conclusion}
\subsection{Summary}
A full pipeline has been implemented backed by our secure tree-storage system Treetank ranging from (extensive) preprocessing, ID-less and ID-based diffing-algorithms to new layout algorithms developed for comparing tree-structures.

Almost all data is subject to preprocessing. Wikipedia has been used to demonstrate the feasibility of our approach for comparing the temporal evolution of several articles by their inherent tree-structure. The Wikimedia Foundation provides only full Wikipedia dumps which are not sorted by revision-timestamps. Therefore it must be sorted at first using Hadoop. Importing structural changes which should be revealed by the visualizations afterwards requires a diff-algorithm which does not expect unique node IDs. Thus the FMSE-algorithm described in Chapter \ref{sec::relwork} has been implemented (Chapter \ref{sec::differences}) as well as several missing edit-operations in Treetank (\texttt{copy}, \texttt{move}, \texttt{replace}), whereas others have been extended to adhere to the XPath/XQuery Data Model (XDM) to simplify the internal ID-based diff-algorithm and to add to the visualizations' expressiveness\footnote{for instance no two adjacent text-nodes are ever created}. The FMSE-algorithm is furthermore useful to compare multiple similar trees. In both cases either the evolution of a tree or different trees are imported as snapshots/revisions in a single Treetank resource. In the latter case changes between a base tree and several other trees are imported. Leveraging the ID-based diff-algorithm the small multiple display differential variant visualizes the comparison between two revisions/trees in currently four regions of the screen (top left, top right, bottom right, bottom left). Other studied applications include the comparison of snapshots of a directory in a filesystem and two revisions of XML-exported LFG-grammars.

An ID-based diff-algorithm has been developed to compare imported data based on snapshots/revisions, whereas the comparison is \emph{not} restricted to both subsequent revisions and whole documents. It supports two modes. Either only structural-nodes which denote the structure of a tree (currently the subset of XML nodes \texttt{DocumentNode}, \texttt{ElementNode} and \texttt{TextNode}s) or both structural- and non-structural nodes (additionally \texttt{NamespaceNode}s and \texttt{AttributeNode}s) are compared. A fast version utilizes hash-values of each node which are generated during import. These are derived from the node's descendants and used to reduce the runtime of the algorithm. The whole subtree of nodes with identical hash-values is skipped.

All visualizations capable of visualizing an aggregated tree-structure trigger the ID-based diff-algorithm if needed. A specialized \emph{SunburstView} visualizes the aggregated tree-structure which is build through collecting diff-tuples observed from the diff-algorithm. A selection of a new root-node together with a simple undo-operation allows to drill down into the tree as known from other Sunburst-visualizations. However the costly recalculation of diff-tuples, modifications and subtree-sizes of each node is omitted in almost all cases. Instead we recalculate the maximum depth of unchanged nodes and scale a new list of items to fit the new boundaries. A notable exception is the item-size based pruning as the diff-tuples are usually not saved to avoid their constant in-memory space consumption. Instead they are subject to garbage collection. The type of diff however is saved in the created Sunburst item and used by the visualization through color coding. A novel Sunburst layout algorithm has been designed to specifically support the analysis of structural changes, which are featured prominently between two rings whereas the ring which is closer to the root node encloses almost all unchanged nodes except those who are in subtrees of updated nodes. The second ring denotes the maximum depth of changed nodes. Thus the area between the two rings encloses all changed nodes as well as unchanged nodes in the subtree of updated nodes. The first changed node in a subtree is dislocated from its original place to reside between the two rings supporting a tree-ring metaphor based on the analogy of an aging tree in the nature which adds growth rings every year. Note, that the analogy is especially appropriate for temporal tree-structures from which our approach emerged. 

The \emph{SunburstView} in comparison mode furthermore facilitates the comparison of large trees by utilizing one of three available pruning techniques. First, an item-size based approach to filter nodes based on their extend is provided. It speeds up the creation of Sunburst items, but does not affect the runtime of the diff-algorithm used in the first place. Second, a method utilizing the hash-based diff-option skips whole subtrees of unchanged nodes with identical hash-values and thus builds solely interesting items to the task at hand (which is analysing structural and non-structural changes). A third variant even skips the creation of items for nodes with unchanged content and identical hash-values altogether. This variant is especially interesting for very large tree-structures to minimize the runtime as well as the memory consumption and to provide maximum space for potentially interesting subtrees with changed nodes.

Besides, sometimes it is interesting to view the whole aggregated tree in an overview. To emphasize structural changes in addition to our semantic zoom the arc of an item is based on the \texttt{subtree-size} of a node as well as of the number of modifications in its subtree. A slider facilitates the setting of how much impact the number of modifications has. Note that the number of modifications is multiplied by a constant factor as modifications are usually small compared to the whole tree. Furthermore the \texttt{subtree-size} must be added as a fallback which is needed to cover the case of zero modifications in the subtree.

In addition to a novel Sunburst layout we provide three different small multiple display variants. Two of them, the incremental- and the differential-view compute the diffs and the subsequent visualizations in each of the four screen regions (top-left, top-right, bottom-right, bottom-left assuming five subsequent revisions of the tree-structure to compare exist) in parallel. The incremental variant displays changes related to a sliding window of two subsequent revisions. The differential version displays changes related to the opened base revision, that is either a reference tree if multiple similar trees are compared or a snapshot of a temporal tree-structure. On mouse-over items are highlighted in each small multiple in which they are present. Compared to an icicle-view which connects unchanged items in each revision by splines our approach features changes much more prominently through the semantic zoom/the tree-ring metaphor as well as the inclusion of the number of modifications to determine the arc (start- and end-angle) of a Sunburst item. A hybrid variant currently suffers from a lack of visually distinguishable colors to encode the type of change. Furthermore nodes added and removed or vice versa during the comparison of multiple revisions are not visible as the overall aggregation which is visualized in each small multiple are build through comparing the opened base-revision and the last revision. However to provide an expressive view merging diff-tuples during subsequent comparisons of all revisions to an aggregation is necessary. Yet, a first implementation proved to be too slow in informal tests.

%In addition to the new Sunburst layout supporting comparisons several small multiple display variants, based on the \emph{SunburstView} have been developed to support the comparison of currently at most five revisions. An incremental version displays changes related to a sliding window of two subsequent revisions. The left upper view shows a comparison between the loaded baseRevision and $baseRevision + 1$, the right upper view displays the comparsion between $baseRevision + 1$ and $baseRevision + 2$ whereas the comparison between two subsequent revisions is done clockwise until either no more revisions are available or five revisions have been compared (all four squarified regions are filled with Sunburst views). A differential version compares subsequent revisions to the loaded baseRevision. This version is ideal to compare different tree-structures to a reference tree. A hybrid view first compares the baseRevision with the newest revision which can be drawn in the bottom left square of the visualization. Subsequently it computes differences just like in the incremental version but blackens changes which occur in subsequent incremental comparisons. The color denoting the type of change of a node gradually lightens.

\subsection{Conclusion}
We presented several visualizations and diffing-algorithms tailored to the comparison of tree-structures. In retrospective the goals described in the introduction have been achieved. The GUI-frontend embedding the visualizations aids analysts in comparing tree-structures ranging from temporal- to similar-trees. As we were not able to find suitable pylogenetic trees our empirical evaluation of comparing multiple similar trees falls short in this respect. However, in general besides having to compare several trees to a reference-tree the visualizations do not differ and our differential small multiple variant especially supports this case.

Our approach based on a tight storage integration supports several edit-operations and respective types of differences such as an optional move-detection determined by our ID-based diffing-algorithm in order to utilize an expressive aggregated tree-structure. Unlike the straight forward approach of building two in memory data structures with nodes of both revisions which intersected our algorithm uses less space and thus is much more useful. Furthermore it supports replace-, update- and move-operations and corresponding diff-types, requires constant space (neglecting the overhead of storing the aggregation) and is faster due to the support of hash-values to skip the traversal of identical subtrees. 

Filtering-mechanisms facilitate the comparison of very large tree-structures. Note that besides CodeFlows\cite{telea2008code} and Treevolution\cite{theron2006hierarchical} no other approach described in Chapter \ref{sec::relwork} to the best of our knowledge provides such filters and therefore most likely are not useful to inspect large datasets. Two filtering techniques depend on hashes which are used to compare the whole subtree of a node including itself. Subtrees are skipped from comparison if the hashes are identical. Thus they are neither traversed nor items are build subsequently.

To the best of our knowledge it is the only approach besides the work presented in \cite{bremm2011interactive} capable of displaying comparisons through various linked visualizations depicting the tree-structures at various levels of detail. Small multiple displays provide a high level view of the differences between multiple tree-structures. Linking and brushing techniques highlight nodes. %The \emph{SunburstView} incorporates both a mode to visualize one tree-structure and a mode to visualize comparisons between two tree-structures. A new layout-algorithm facilitates comparing tree-structures through highlighting changes in a prominent place with a global distortion. Furthermore different filtering methods allow the comparison of large trees. Details are shown on demand through a mouse-over effect and a linked \texttt{TextView}. A selection of a new root-node togehter with a simple undo-operation allows to drill down into the tree as known from other Sunburst-visualizations. However the costly recalculation of diff-tuples, modifications and subtree-sizes of each node is omitted in all cases but the item-size-based pruning. Instead we recalculate the maximum depth of unchanged nodes and scale a new list of items to fit the new boundaries. The \texttt{TextView} provides a serialization of (sub)trees linked with the \texttt{SunburstView} also tailored to large tree-structures.

Unlike State of the Art visualizations of tree comparisons described in Chapter \ref{sec::relwork} our approach is entirely database driven. The DBMS is tailored to temporal tree-structures which are stored as transaction time snapshots. Each node in the database/resource is unique and remains stable throughout all revisions. As most trees do not inhibit unique node-IDs our FMSE-implementation is used to compare and import encountered differences which eventuates in new a new revision each time the algorithm is invoked. Once the tree-structures or revisions thereof are imported, we are able to use our fast ID-based diff-algorithm ($O(n+m)$) based on the generated node-IDs.
 
The next sub-section evaluates our approach similar to Chapter \ref{sec::relwork} but in more detail in respect to our approach according to several attributes.

\subsubsection{Evaluation Criteria}

\begin{itemize}
\item \emph{SpaceFilling} Space filling techniques try to maximize the usage of available screen space and thus facilitate a high information density. Sunburst layouts are space filling, but in contrast to Treemaps lack space filling properties in the corners. However in our case the corners are used to display GUI components and legends. Our small multiple variants currently require too much unused space as we trigger a normal sunburst visualization each time occupying the whole view-port which is afterwards downscaled. However usually the view-port is rectangular instead of squarified whereas the width most often is greater then the height depending on the extends of the main window. Thus, space is unused at the left- and right-border of the visualization. In a future version we will use a squarified clip of the view depending on the maximum depth to generate minimized off-screen buffers. Other space filling approaches include Icicle plots (Code Flows) which are comparable in space consumption as always the two complete tree-structures to compare are plottet. In our case unchanged nodes are not plotted twice. A special stable Spiral-Treemap layout has been proposed which utilizes all available screen space and remains relatively stable after changes. Usual Treemap layouts suffer from abrupt layout changes during modifications of the underlying data.
\item \emph{Hierarchy} The Hierarchy in Sunburst layouts is very well depicted due to the adjacency based layout whereas it is not as obvious in Treemaps which encapsulate children in parent-rectangles. Cushion Treemaps have been developed for better readability of hierarchical relationships using shading. However, compared to adjacency based layouts they still suffer from worse readability. Code flows utilizes Icicle plots which are rectangular views of the radial Sunburst layout, thus adjacency based and very well readable. Our approach optionally plots a node-link diagram on top of the Sunburst layout to further illustrate the relationships such that the hierarchy is at least as well depicted as in other node-link diagrams (for instance in TreeJuxtaposer and Treevolution). To draw a node-link diagram on top of a Sunburst layout furthermore facilitates a higher information density. Individual nodes in the node-link overlay are color-coded based on their type of difference. Furthermore their child/parent relationship, the links between the nodes are displayed through connections (straight lines or bezier curves). Thus, we are able to map attributes to the arc/extension of the Sunburst items, the color of the arcs and the color of the dots/nodes in the node-link diagram. The radius of the nodes in the node-link diagram however currently is not used to encode another attribute. To maximize the information density theoretically it is possible to use histograms in the Sunburst items instead of just using one color for the whole item to visualize multiple attributes instead of one. However we are confident that the items usually are too small, such that a whole histogram in very small items is certainly not readable. 
\item \emph{Labels} Labels in a Sunburst-view are usually plotted in a radial layout, otherwise overplotting occurs. To support better readability of item-labels our visualization is able to be rotated. However, node labels of Treemaps and Icicle plots usually are better readable due to their rectangular display in comparison to circular plotted labels. Thus we decided to extend our \emph{TextView} to take the aggregated tree-structure into account. It is an ideal partner of the \emph{SunburstView} as it provides better readability of small subtrees but lacks an overview about the entire tree and all differences which are depicted by the \emph{SunburstView}. Furthermore moves are not visualizable (at least no links).
\item \emph{Similarity of ID-less tree-structures} Some proposed tree-to-tree comparison visualizations depend on node-IDs (Spiral-/Contrast-Treemap\cite{tu2007visualizing}) or the comparison technique has not been mentioned. Others depend on domain characteristics (Treejuxtaposer\cite{munzner2003treejuxtaposer}, Code Flows\cite{telea2008code}). Juxtaposer seems to rely on unique leaf-node labels. Otherwise it is not obvious how to map node labels to their postorder rank on a region plane. In contrast to Treejuxtaposer and other proposed systems our prototype is able to compare every kind of tree-structure.
\item \emph{Structural changes} Our visualizations, in particular the \emph{SunburstView} and the small multiple display variants support the highlighting of all kind of structural-changes (inserts, deletes, updates, replace and move-operations) through color-encoded items. In case of moves links, currently depicted as arrows, denote the movement from their original- to their target-place using hierarchical edge bundling to avoid or at least reduce visual clutter due to overlapping lines or curves. Furthermore the arc of the sunburst items depends on the node's subtree size \emph{and} the number of modifications in the therein. Most other visualizations do not provide a global distortion to further emphasize changes except Treejuxtaposer to the best of our knowledge.
\item \emph{Non structural changes} are value changes of nodes. Changes in \texttt{TextNode}s are color coded to denote that the value is \texttt{UPDATED} through coloring the node in the overlapping node-link diagram accordingly. Furthermore the color of the Sunburst item reflects their similarity using the Levenshtein distance.
\item \emph{Filtering} is one of our primary concerns. The focus of this thesis evolved around the idea of comparing Treetank-resources by interactive visualizations. As Treetank is a secure storage system it naturally often times stores very large tree-structures. Thus, our first consideration was to prune items which cannot be visually perceived, that is Sunburst items which are too small are not created. However this only affects the creation of Sunburst items and does not improve the ID-based diff-algorithm. To speed up both, the ID-based diff algorithm as well as the construction of Sunburst items we developed a diff-algorithm variant which skips subtrees of nodes with identical hash-values and thus moves both transactions to the next node in the XPath \texttt{following::}-axis. Accordingly, in case large subtrees are skipped the diff-algorithm using hash-comparisons is much faster. Besides, even less items usually have to be created and in case of a subtree-selection to drill down into the tree only the item-sizes have to be recalculated instead of re-invoking the diff-algorithm, recalculate the subtree-size and the number of modifications for each node, and the preorder traversal of the aggregated tree-structure with all stack-adjustments is unnecessary. Pushing the idea of filtering by hash-values to its limits involves to avoid the creation of items for the nodes with identical hash-values. These filtering techniques furthermore enlarge changed subtrees naturally as the arc of the items is based on the \emph{subtree-size} of each node and the number of \emph{modifications} therein. TreeJuxtaposer once more along with Code Flows to the best of our knowledge seems to be the only system which is able to handle large tree-structures but the diff-algorithm of TreeJuxtaposer relies on unique node labels. Code Flows does not provide a global filtering method such that their filtering is comparable with our method to drill down into the tree. However, due to filtering by queries the filtering is mightier. Implementing such a behavior in our prototype will be straight forward allowing the user to specify an XPath-query and invoke the diff-algorithm for each result on both revisions. Our current approach is able to filter differences and related context nodes on a global basis and on subtrees once a user drilled down into the Sunburst visualization with a guaranteed visibility of modifications much like in TreeJuxtaposer.
\end{itemize}

Table \ref{chap5:comparison} summarizes all visualization-approaches according to the evaluation criteria specified above.

\begin{table}[tb]
\begin{minipage}{\linewidth}
\centering 
\begin{tabularx}{0.8\textwidth}{|l|>{\centering\arraybackslash}X|>{\centering\arraybackslash}X|>{\centering\arraybackslash}X|>{\centering\arraybackslash}X|>{\centering\arraybackslash}X|>{\centering\arraybackslash}X|>{\centering\arraybackslash}X|} 
\hline
\centering\textbf{visualization approaches} & \begin{sideways}\textbf{space filling}\end{sideways} & \begin{sideways}\textbf{hierarchy}\end{sideways} & \begin{sideways}\textbf{labels}\end{sideways} & \begin{sideways}\textbf{ID-less comparison}\end{sideways} & \begin{sideways}\textbf{structural changes}\end{sideways} & \begin{sideways}\textbf{non structural changes\ }\end{sideways} & \begin{sideways}\textbf{filtering}\end{sideways}\\
\hline
\hline
\textbf{Sunburst} & o & + & +\footnote{the labels are better readable in Treemaps and Icicle plots due to their rectangular nature instead of drawing the label on an arc} & + & + & + & +\\
\hline
\textbf{Spiral-/Contrast-Treemap} & + & o & + & - & o & + & -\\
\hline
\textbf{Treevolution} & - & o & o\footnote{rotating however might prevent some labels from overplotting} & - & o & - & -\\
\hline
\textbf{Code Flows} & + & + & + & - & o & - & +\\
\hline
\textbf{Juxtaposer} & - & + & o & - & + & - & o \\
\hline
\textbf{Ripple Presentation} & - & + & o & - & + & - & -\\
\hline
\textbf{IVCoMT} & +\footnote{the matrix view} & + & + & - & + & o & -\\
\hline
\end{tabularx}
\label{chap5:comparison}
\vspace{0.5em} 
\caption{Comparing tree-to-tree difference visualizations. Appendix \ref{sec::tablelegend} provides a detailed legend.}
\end{minipage}
\end{table}

%\footnotetext{the labels are better readable in Treemaps and Icicle plots due to their rectangular nature instead of drawing the label on an arc}
%\footnotetext{rotating however might prevent some labels from overplotting}
%\footnotetext{the matrix view}

Most proposed visualizations rely on stable unique IDs (the Contrast\\Treemap\cite{tu2007visualizing}, Code Flows\cite{telea2008code}, TreeJuxtaposer\cite{munzner2003treejuxtaposer} (unique node labels)) and do not include the detection of \texttt{replace}- and \texttt{move}-operations. However Code Flows visualizes moves due to spline connections between matching nodes with the same ID in two adjacent icicle plots. Due to the reliability on unique node IDs these visualizations do not cover trees which do not include unique node-IDs or labels. In contrast our prototype is able to determine and visualize these tree-structures utilizing the FMSE-algorithm to import differences through similarity metrics for each type of supported nodes utilized by a bottom-up LCS computation to determine matching node candidates.

Interactive Visual Comparison of Multiple Trees(IVCoMT\cite{bremm2011interactive}) provides the ability to compare multiple trees through various linked views allowing the comparison on different levels of detail. However we assume that the similarity metrics are defined for phylogenetic trees which have unique labels and that the visualizations are tailored to many small trees in comparison to a few very large tree-structures or a temporal evolving tree as in our case.

\subsection{Future Research}
Many topics are subject to further research. 

\begin{itemize}
\item First of all we want to incorporate already developed temporal XPath axis in an XQuery processor, most probably Brackit\cite{Brackit}, which is important to further analyse temporal evolving tree-structures. Furthermore in order to support fast query-response times it is inevitable to provide indexes. 
\item A recently developed path summary is usable to significantly speed up the comparison of very large tree-structures if isomorphism is not an issue, for instance by providing a high level matrix overview about the changes. 
\item Extend the Hierarchical Edge Bundles to use a gradient color to indicate the direction of moves instead of arrows.
\item Building an index structure for visualizations of consecutive revisions (the small multiple incremental-variant and the SunburstView comparing consecutive revisions).
\item Evaluation and integration/implementation of various other tree-similarity measures.
\item Storing diff-tuples in a main memory Treetank instance and thus computing the subtree-size and the modifications therein in a single postorder traversal before building Sunburst items.
\item Measuring the impact of certain modification-scenarios.
\end{itemize} 
