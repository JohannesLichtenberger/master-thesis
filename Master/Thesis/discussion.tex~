\section{Discussion}\label{sec::discussion}
\subsection{Introduction}
This Chapter concludes the main contribution of this thesis with a discussion of the work presented in relation to the state-of-the-art.

The presented approach facilitates the comparison of tree-structures through various linked visualizations showing the tree-structures at varuous levels of detail. The Small multiple variants of a \emph{SunburstView} provide a high level view of the differences between many tree-structures. Linking and brushing is used to highlight nodes in all small visualizations. The \emph{SunburstView} itself incorporates both a mode to visualize one tree-structure and a mode to visualize comparisons between two tree-structures. A new layout-algorithm has been developed to highlight changes in a prominent place. Furthermore different filtering methods allow the comparison of large trees. Details are shown on demand through a mouseover effect and a linked \texttt{TextView}. A selection of a new root-node togehter with a simple undo-operation allows to drill down into the tree as known from other Sunburst-visualizations. However costly recalculation of diff-tuples, modifications and descendants of each node is omitted in all cases but the itemsize-based pruning. Instead we recalculate the maximum depth of unchanged nodes and scale a new list of items to fit the new boundaries. The \texttt{TextView} provides a low-level serialization of (sub)trees linked with the \texttt{SunburstView} also tailored to large tree-structures.

Unlike other visualizations of tree comparisons we have found and described in Chapter \ref{sec::relwork} our approach is entirely database driven. The DBMS is tailored to temporal tree-structures which are stored as snapshots. Each node in the database/resource is unique and remains stable throughout all revisions. As most trees do not inhibit node-IDs we have implemented an ID-less diff-algorithm called FMSE to import differences. Afterwards we are able to use a faster diff-algorithm based on the node-IDs and furthermore are able to utilize hashes to further speed up the algorithm. Due to FMSE our similarity-measure between trees is based on a matching algorithm which computes the longest common subsequence (LCS) bottom up and furthermore tries to find cross-matches of unmatched nodes.

Most proposed visualizations in contrast rely on stable unique IDs (the Contrast Treemap\cite{tu2007visualizing}, Code Flows\cite{telea2008code}, TreeJuxtaposer\cite{munzner2003treejuxtaposer} (unique node labels)) and do not include the detection of \texttt{replace}- and \texttt{move}-operations. However Code Flows visualizes moves due to spline connections between matching nodes with the same ID in two adjacent icicle plots. Due to the reliability on unique node IDs these visualizations do not cover trees which do not include unique node-IDs. In contrast our prototype is able to determine and visualize these tree-structures utilizing the FMSE-algorithm to import differences through similarity metrics for leaf- and inner-nodes.

The next section evaluates our approach similar to Chapter \ref{sec::relwork} according to several attributes.

\subsection{Evaluation Criteria}

\begin{itemize}
\item \emph{SpaceFilling} Space filling techniques try to maximize the usage of available screen space and thus facilitate a higher information density. Sunburst layouts are generally space filling, but in contrast to Treemaps lack space filling properties in the corners. However in our case the corners are used to display GUI components and legends. The small multiple variants currently have too much unused space which is due to the often times non squarified screen viewport depending on the extends of the main window. As we just scale each visualization of the comparison of each two revisions the small multiple variants currently include too much unused space due to often times non squarified screen viewport which depends (1) on the size of the main window and (2) how many visualizations are currently enabled. Thus, in a future version we will use a squarified clip of the view depending on the maximum depth to generate minimized offscreen buffers for the four regions. Other space filling approaches include Icicle plots (Code Flows) which are comparable in space consumption as always the two complete tree-structures to compare are plottet. In our case unchanged nodes are not plotted twice. Furthermore a special stable Spiral-Treemap layout has been proposed which utilizes all available screen space and remains relatively stable after changes. Usual Treemap layouts suffer from abrupt layout changes during modifications of the underlying data.
\item \emph{Hierarchy} The Hierarchy in Sunburst layouts is very well depicted due to the adjacency based layout whereas it is not as obvious in Treemaps which encapsulate child items. Cushion Treemaps have been developed for better readability of hierarchical relationships using shading. However they are still not as good readable as in adjacency based layouts. Code flows utilizes Icicle plots which are rectangular views of the radial Sunburst layout, thus adjacency based and very well readable. Our approach optionally plots a node-link diagram on top of the Sunburst layout to further illustrate the relationships. Node-link diagrams as for instance used in Treejuxtaposer depicts the hierarchy very well. 
\item \emph{Readability} To both use node-link diagrams and a Sunburst layout facilitates a higher information density as individual nodes can be color-coded as well as their child/parent relationship, the links between the nodes. Thus we are able to utilize to map certain attributes to the extension of the Sunburst items, the color of the arcs, the color of the dots/nodes in the node-link diagram. To maximize the information density we could also use histograms in the Sunburst items instead of just using one color for the whole item. However we assume that usually the items will be too small, such that a whole histogram would possibly not be readable in many cases. To support better readability of item-labels our visualization is able to be rotated. Node labels of Treemaps and Icicle plots however usually are better readable due to their rectangular display in comparison to circular plotted labels. Thus the \emph{TextView} has been extended to take the agglomerated tree-structure into account. It is an ideal partner of the \emph{SunburstView} as it provides better readability of small subtrees but lacks the overall overview about all differences provided by the \emph{SunburstView}. 
\item \emph{Similarity of ID-less tree-structures} Some proposed tree-to-tree comparsion visualizations depend on node-IDs (Spiral-/Contrast-Treemap\cite{tu2007visualizing}) or the comparison technique has not been meantioned. Others depend on domain characteristics (Treejuxtaposer\cite{munzner2003treejuxtaposer}, Code Flows\cite{telea2008code}). Juxtaposer seems to rely on unique leaf node labels. Otherwise it is not obvious how to map node labels to their postorder rank on a region plane. Furthermore phylogenetic trees are leaf labeled, whereas we also consider labeled inner nodes. In contrast to Treejuxtaposer our prototype is able to compare every kind of tree-structure.
\item \emph{Structural changes} Our visualizations, in particular the \emph{SunburstView} and the small multiple variants support the highlighting of all kind of structural-changes (inserts, deletes, updates, replace and move-operations) through color-coded nodes. In case of moves- links, currently depicted as arrows, denote the movement from their original- to their target-place using hierarchical edge bundling to avoid or at least reduce visual clutter due to overlapping lines or curves. Furthermore the extend of the sunburst items is based on the nodes' subtree size \emph{and} the number of modifications in the subtree. Most other visualizations do provide a global distortion to further emphasize changes except Treejuxtaposer to the best of our knowledge.
\item \emph{Non structural changes} in \texttt{TextNode}s are color coded to denote that the value is \texttt{UPDATED} through coloring the node in the overlapping node-link diagram accordingly. Furthermore the color of the SunburstItem reflects their Levenshtein String-similarity.
\item \emph{Filtering} is one of our primariy concerns. The focus of this thesis evolved around comparing Treetank-resources. As Treetank is a secure storage system it naturally often times stores very large tree-structures. Thus our first consideration was to filter items which can be perceived, that is too small items are not created. However this only effects the creation of SunburstItems and does not concern the ID-based diff-algorithm. To speed up both, the ID-based diff algorithm as well as the construction of SunburstItems we developed the diff-algorithm which skips subtrees with same hashes and moves both transactions to the next node on the XPath-following axis. Thus, in case large subtrees can be skipped the diff-algorithm using hash-comparisons is much faster. Besides even less items have to be created and in case of a subtree-selection only the itemsizes have to be recalculated instead of reinvoking the diff-algorithm, recalculate the descendant- and modification-count, and the whole preorder traversal of the agglomerated tree-structure with all stack-adjustements. Pushing the idea of filtering by hashvalues to its limits involves to avoid the creation of SunburstItems for the nodes, which have the same hashvalues. These filtering techniques furthermore enlarge changed subtrees naturally as the extend of the items is based on the \emph{descendant-count} of each node and the \emph{modification-count}. Note that the \emph{descendant-count} includes the node itself, that is all nodes in the subtree plus one. Treejuxtaposer once more to the best of our knowledge seems to be the only system which can handle large tree-structures but their diff-algorithm relies on unique node labels.
\end{itemize}
